# ğŸ“Š ç¬¬10ç« ï¼šç”Ÿäº§åŠ›ä¸é¡¹ç›®ç®¡ç†

> **æœ¬ç« ç›®æ ‡**ï¼šå°†AI Agentä»"å¯¹è¯åŠ©æ‰‹"å‡çº§ä¸ºä½ çš„**ç”Ÿäº§åŠ›æ“ä½œç³»ç»Ÿ**â€”â€”ä»æ¯å¤©æ—©æ™¨çš„ä¿¡æ¯æ±‡æ€»ï¼Œåˆ°å¤šäººé¡¹ç›®çš„è‡ªä¸»ç®¡ç†ï¼Œå†åˆ°å®¶åº­æ—¥ç¨‹çš„æ™ºèƒ½åè°ƒã€‚æˆ‘ä»¬å°†æ·±å…¥4ä¸ªå®Œæ•´çš„ç”Ÿäº§åŠ›ç³»ç»Ÿå®ç°ï¼Œè®©Agentæˆä¸ºä½ å·¥ä½œå’Œç”Ÿæ´»ä¸­ä¸å¯æˆ–ç¼ºçš„ä¼™ä¼´ã€‚

ç”Ÿäº§åŠ›å·¥å…·çš„æ¼”å˜å²ï¼Œå°±æ˜¯ä¸€éƒ¨"ä»å·¥å…·åˆ°ç³»ç»Ÿ"çš„è¿›åŒ–å²ã€‚æˆ‘ä»¬ä»çº¸ç¬”æ¸…å•ï¼Œåˆ°æ•°å­—å¾…åŠäº‹é¡¹ï¼Œå†åˆ°ä»Šå¤©çš„AI Agentâ€”â€”ä½†å¤§å¤šæ•°äººè¿˜åœç•™åœ¨"ç”¨AIèŠå¤©"çš„é˜¶æ®µã€‚æœ¬ç« å°†å¸¦ä½ è·¨è¶Šè¿™é“é¸¿æ²Ÿï¼Œæ„å»ºçœŸæ­£çš„**è‡ªåŠ¨åŒ–ç”Ÿäº§åŠ›ç³»ç»Ÿ**ã€‚

**æœ¬ç« æ¡ˆä¾‹è·¯çº¿å›¾**ï¼š
```
10.1 ä¸ªäººç”Ÿäº§åŠ› â†’ Morning Briefing + Email Triage + Multi-Channel Assistant
10.2 é¡¹ç›®ç®¡ç† â†’ Autonomous PM + STATE.yamlå®æˆ˜ + å¤šAgentåä½œ
10.3 å®¶åº­åä½œ â†’ æ—¥å†èšåˆ + å†²çªæ£€æµ‹ + Multi-Channelå®¢æœç³»ç»Ÿ
```

ä¸ç¬¬8ç« ï¼ˆä¿¡æ¯èšåˆï¼‰å’Œç¬¬9ç« ï¼ˆå†…å®¹ç”Ÿäº§ï¼‰ä¸åŒï¼Œæœ¬ç« å…³æ³¨çš„æ˜¯**æ‰§è¡Œä¸åè°ƒ**ï¼šä¸ä»…è¦æ”¶é›†ä¿¡æ¯ï¼Œè¿˜è¦é‡‡å–è¡ŒåŠ¨ï¼›ä¸ä»…è¦è‡ªå·±åšäº‹ï¼Œè¿˜è¦åè°ƒå¤šäºº/å¤šAgentã€‚è¿™æ˜¯ç”Ÿäº§åŠ›ç³»ç»Ÿçš„æ ¸å¿ƒæŒ‘æˆ˜ã€‚

---

## ğŸ¯ 10.1 ä¸ªäººç”Ÿäº§åŠ›ç³»ç»Ÿ

### 10.1.1 é—®é¢˜çš„æœ¬è´¨ï¼šä¿¡æ¯è¿‡è½½ä¸æ‰§è¡Œæ–­å±‚

**ç°ä»£äººçš„ç”Ÿäº§åŠ›å›°å¢ƒ**ï¼š
- **æ—©æ™¨é†’æ¥**ï¼šæ‰“å¼€5ä¸ªAppæŸ¥çœ‹ä»Šå¤©è¦åšä»€ä¹ˆï¼ˆæ—¥å†ã€é‚®ä»¶ã€ä»»åŠ¡ã€å¤©æ°”ã€æ–°é—»ï¼‰
- **é‚®ä»¶å †ç§¯**ï¼š200å°æœªè¯»é‚®ä»¶ï¼Œä¸€åŠæ˜¯Newsletterï¼Œ20%é‡è¦ä½†è¢«æ·¹æ²¡
- **ä»»åŠ¡åˆ†æ•£**ï¼šTodoisté‡Œçš„ä»»åŠ¡ã€Slacké‡Œçš„å¾…åŠã€Emailé‡Œçš„è·Ÿè¿›ï¼Œä¸‰ä¸ªåœ°æ–¹è®°ç€åŒä¸€ä»¶äº‹
- **è¢«åŠ¨å“åº”**ï¼šæ•´å¤©åœ¨Telegramã€Slackã€Emailä¹‹é—´åˆ‡æ¢ï¼Œæ²¡æœ‰ä¸»åŠ¨æ—¶é—´

è¿™ä¸æ˜¯"æ‡’"ï¼Œè€Œæ˜¯**ç³»ç»Ÿè®¾è®¡é—®é¢˜**ã€‚äººè„‘ä¸æ“…é•¿åš"åˆ‡æ¢ä¸Šä¸‹æ–‡"å’Œ"è®°ä½ä¸€åˆ‡"ï¼Œä½†æˆ‘ä»¬çš„å·¥å…·è¦æ±‚æˆ‘ä»¬è¿™ä¹ˆåšã€‚

**AI Agentçš„ä¼˜åŠ¿**ï¼š
1. **ä¸»åŠ¨èšåˆ**ï¼šæ¯å¤©æ—©æ™¨è‡ªåŠ¨æ±‡æ€»å…³é”®ä¿¡æ¯ï¼ˆMorning Briefingï¼‰
2. **è‡ªåŠ¨åˆ†ç±»**ï¼šé‚®ä»¶è‡ªåŠ¨åˆ†ç±»ã€æ ‡è®°ã€å½’æ¡£ï¼ˆEmail Triageï¼‰
3. **ç»Ÿä¸€å…¥å£**ï¼šTelegramä¸€ä¸ªç•Œé¢æ“ä½œæ‰€æœ‰ç³»ç»Ÿï¼ˆMulti-Channel Assistantï¼‰
4. **æŒç»­åŒæ­¥**ï¼šä»»åŠ¡ã€æ—¥ç¨‹ã€ç¬”è®°è‡ªåŠ¨åŒæ­¥ï¼ˆTodoist Task Managerï¼‰

æ¥ä¸‹æ¥æˆ‘ä»¬é€ä¸€å®ç°è¿™4ä¸ªç³»ç»Ÿã€‚

---

### 10.1.2 æ¡ˆä¾‹1ï¼šMorning Briefing - ç”Ÿäº§åŠ›çš„æ—©æ™¨ä»ªå¼[^morning-brief-ch10]

[^morning-brief-ch10]: æ¡ˆä¾‹æ¥æºï¼š[Custom Morning Brief](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/custom-morning-brief.md)ï¼Œawesome-openclaw-usecases ç¤¾åŒºè´¡çŒ®

**è®¾è®¡ç›®æ ‡**ï¼š
æ¯å¤©æ—©æ™¨8ç‚¹ï¼ŒAgentè‡ªåŠ¨æ±‡æ€»å¹¶å‘é€ï¼š
- ä»Šæ—¥å¤©æ°”ä¸ç©¿è¡£å»ºè®®
- æ—¥å†ä¸Šçš„ä¼šè®®å’Œäº‹ä»¶ï¼ˆé«˜äº®å†²çªï¼‰
- æœªè¯»é‚®ä»¶æ‘˜è¦ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
- æ˜¨å¤©æœªå®Œæˆçš„ä»»åŠ¡
- ç³»ç»Ÿå¥åº·çŠ¶å†µï¼ˆæœåŠ¡å™¨ã€é¡¹ç›®è¿›åº¦ï¼‰

**æ¶æ„è®¾è®¡**ï¼š
```yaml
# Morning Briefing Architecture
è§¦å‘å™¨: Cron (æ¯å¤©8:00 AM)
æ•°æ®æº:
  - weather_api (OpenWeatherMap)
  - google_calendar
  - gmail_api (æœªè¯»é‚®ä»¶)
  - todoist_api (ä»Šæ—¥ä»»åŠ¡)
  - uptime_kuma (æœåŠ¡å™¨çŠ¶æ€)
è¾“å‡º: Telegramæ¶ˆæ¯ï¼ˆç»“æ„åŒ–å‘ˆç°ï¼‰
```

> ğŸ’¡ **AIè¾…åŠ©æç¤º**ï¼šä¸ç†Ÿæ‚‰Cronè¯­æ³•ï¼Ÿé—®ChatGPTï¼š"å¦‚ä½•å†™ä¸€ä¸ªæ¯å¤©æ—©æ™¨8ç‚¹æ‰§è¡Œçš„Cronè¡¨è¾¾å¼ï¼Ÿ"AIä¼šè§£é‡Š`0 8 * * *`çš„å«ä¹‰ï¼Œå¹¶ç»™å‡ºæ›´å¤šç¤ºä¾‹ã€‚

#### æ­¥éª¤1ï¼šå®‰è£…å¿…è¦çš„Skill

```bash
# å¤©æ°”
openclaw skill install weather

# Google Calendaré›†æˆ
openclaw skill install google-calendar

# Gmailé›†æˆï¼ˆä½¿ç”¨OAuthï¼Œä¸æ˜¯å¯†ç ï¼‰
openclaw skill install gmail

# Todoisté›†æˆ
openclaw skill install todoist

# ç³»ç»Ÿç›‘æ§
openclaw skill install uptime-kuma
```

æ¯ä¸ªSkillå®‰è£…åä¼šè¦æ±‚é…ç½®APIå¯†é’¥æˆ–OAuthæˆæƒã€‚Gmailå’ŒGoogle Calendarä½¿ç”¨OAuthï¼Œæ›´å®‰å…¨ï¼ˆä¸éœ€è¦å¯†ç ï¼‰ã€‚

#### æ­¥éª¤2ï¼šè®¾è®¡Briefingæ¨¡æ¿

åœ¨`workspace/skills/morning-briefing/template.yaml`ï¼š

```yaml
# Morning Briefing Template
sections:
  - name: weather
    title: "ğŸŒ¤ï¸ ä»Šæ—¥å¤©æ°”"
    format: |
      {location}: {condition} {temp}Â°C (ä½“æ„Ÿ{feels_like}Â°C)
      ğŸ’§ æ¹¿åº¦{humidity}% | ğŸŒ¬ï¸ é£é€Ÿ{wind_speed}km/h
      å»ºè®®: {advice}
    
  - name: calendar
    title: "ğŸ“… ä»Šæ—¥æ—¥ç¨‹"
    format: |
      {time} - {event_name}
      {location_if_any}
      [è·ç¦»è¿˜æœ‰{time_until}]
    highlight_conflicts: true
    
  - name: email
    title: "ğŸ“§ é‡è¦é‚®ä»¶"
    filters:
      - important: true
      - unread: true
      - not_newsletter: true
    max_items: 5
    format: |
      ã€{priority}ã€‘{sender}: {subject}
      {preview_50_chars}
    
  - name: tasks
    title: "âœ… ä»Šæ—¥ä»»åŠ¡"
    sources:
      - todoist.today
      - todoist.overdue
    format: |
      {priority_emoji} {task_name}
      {due_time_if_any}
    
  - name: system
    title: "ğŸ–¥ï¸ ç³»ç»ŸçŠ¶æ€"
    checks:
      - uptime_kuma.services
      - github_actions.workflows (å¤±è´¥çš„)
      - openclaw.agent_health
    format: |
      {status_emoji} {service_name}: {status}
```

#### æ­¥éª¤3ï¼šå®ç°æ•°æ®èšåˆé€»è¾‘

åœ¨`workspace/agents/morning-briefing.py`ï¼ˆAgentä»£ç ï¼‰ï¼š

```python
import openclaw
from datetime import datetime, timedelta

class MorningBriefingAgent:
    def __init__(self):
        self.weather = openclaw.skill("weather")
        self.calendar = openclaw.skill("google-calendar")
        self.gmail = openclaw.skill("gmail")
        self.todoist = openclaw.skill("todoist")
        self.uptime = openclaw.skill("uptime-kuma")
        
    async def run(self):
        """æ¯å¤©æ—©æ™¨æ‰§è¡Œ"""
        sections = []
        
        # 1. å¤©æ°”
        weather = await self.weather.get_current("Tokyo")
        weather_section = self._format_weather(weather)
        sections.append(weather_section)
        
        # 2. æ—¥å†
        today_events = await self.calendar.get_events(
            start=datetime.now(),
            end=datetime.now() + timedelta(days=1)
        )
        calendar_section = self._format_calendar(today_events)
        sections.append(calendar_section)
        
        # 3. é‚®ä»¶
        important_emails = await self.gmail.search(
            query="is:unread -category:promotions -category:social",
            max_results=10
        )
        # AIè¿‡æ»¤ï¼šåªä¿ç•™çœŸæ­£é‡è¦çš„
        filtered = await self._ai_filter_emails(important_emails)
        email_section = self._format_emails(filtered)
        sections.append(email_section)
        
        # 4. ä»»åŠ¡
        tasks = await self.todoist.get_tasks(
            filter="(today | overdue) & !subtask"
        )
        task_section = self._format_tasks(tasks)
        sections.append(task_section)
        
        # 5. ç³»ç»ŸçŠ¶æ€
        services = await self.uptime.get_status()
        system_section = self._format_system(services)
        sections.append(system_section)
        
        # ç»„è£…æ¶ˆæ¯
        message = self._assemble_briefing(sections)
        
        # å‘é€åˆ°Telegram
        await openclaw.message.send(
            target="telegram:me",
            text=message
        )
    
    def _format_weather(self, w):
        """æ ¼å¼åŒ–å¤©æ°”ä¿¡æ¯"""
        # ç©¿è¡£å»ºè®®
        if w.temp < 10:
            advice = "å¯’å†·ï¼Œå»ºè®®ç©¿åšå¤–å¥—ğŸ§¥"
        elif w.temp < 20:
            advice = "å‡‰çˆ½ï¼Œå»ºè®®ç©¿å¤–å¥—ğŸ‘•"
        else:
            advice = "æ¸©æš–ï¼ŒTæ¤å³å¯ğŸ‘”"
        
        if w.rain_probability > 50:
            advice += " + å¸¦ä¼â˜”"
        
        return f"""ğŸŒ¤ï¸ **ä»Šæ—¥å¤©æ°”**
{w.location}: {w.condition} {w.temp}Â°C (ä½“æ„Ÿ{w.feels_like}Â°C)
ğŸ’§ æ¹¿åº¦{w.humidity}% | ğŸŒ¬ï¸ é£é€Ÿ{w.wind_speed}km/h
å»ºè®®: {advice}
"""
    
    def _format_calendar(self, events):
        """æ ¼å¼åŒ–æ—¥å†äº‹ä»¶"""
        if not events:
            return "ğŸ“… **ä»Šæ—¥æ—¥ç¨‹**: æ— å®‰æ’"
        
        lines = ["ğŸ“… **ä»Šæ—¥æ—¥ç¨‹**:"]
        
        # æ£€æµ‹å†²çª
        conflicts = self._detect_conflicts(events)
        
        for event in sorted(events, key=lambda e: e.start):
            time_str = event.start.strftime("%H:%M")
            time_until = self._format_time_until(event.start)
            
            conflict_mark = "âš ï¸ " if event.id in conflicts else ""
            
            lines.append(
                f"{conflict_mark}{time_str} - {event.summary}"
            )
            if event.location:
                lines.append(f"  ğŸ“ {event.location}")
            lines.append(f"  [è·ç¦»è¿˜æœ‰{time_until}]")
        
        if conflicts:
            lines.append("\nâš ï¸ å‘ç°æ—¶é—´å†²çªï¼")
        
        return "\n".join(lines)
    
    def _detect_conflicts(self, events):
        """æ£€æµ‹æ—¶é—´å†²çª"""
        conflicts = set()
        for i, e1 in enumerate(events):
            for e2 in events[i+1:]:
                if self._events_overlap(e1, e2):
                    conflicts.add(e1.id)
                    conflicts.add(e2.id)
        return conflicts
    
    async def _ai_filter_emails(self, emails):
        """ä½¿ç”¨AIè¿‡æ»¤çœŸæ­£é‡è¦çš„é‚®ä»¶"""
        if len(emails) <= 5:
            return emails
        
        # æ„å»ºprompt
        email_summaries = [
            f"{i+1}. From: {e.sender}, Subject: {e.subject}, Preview: {e.preview[:100]}"
            for i, e in enumerate(emails)
        ]
        
        prompt = f"""ä½ æ˜¯ä¸€ä¸ªé‚®ä»¶ä¼˜å…ˆçº§ä¸“å®¶ã€‚ä»ä»¥ä¸‹{len(emails)}å°é‚®ä»¶ä¸­é€‰å‡ºæœ€é‡è¦çš„5å°ï¼ˆå·¥ä½œç›¸å…³ã€æ—¶æ•ˆæ€§ã€éœ€è¦è¡ŒåŠ¨ï¼‰ã€‚

é‚®ä»¶åˆ—è¡¨ï¼š
{chr(10).join(email_summaries)}

è¿”å›æ ¼å¼ï¼š[é‚®ä»¶ç¼–å·åˆ—è¡¨]ï¼Œä¾‹å¦‚ï¼š[1, 3, 5, 7, 9]
"""
        
        response = await openclaw.ai.query(prompt)
        # è§£æAIè¿”å›çš„ç¼–å·
        import re
        numbers = re.findall(r'\d+', response)
        indices = [int(n)-1 for n in numbers[:5]]
        
        return [emails[i] for i in indices if i < len(emails)]
    
    def _format_emails(self, emails):
        """æ ¼å¼åŒ–é‚®ä»¶åˆ—è¡¨"""
        if not emails:
            return "ğŸ“§ **é‡è¦é‚®ä»¶**: æ— "
        
        lines = ["ğŸ“§ **é‡è¦é‚®ä»¶**:"]
        
        for email in emails[:5]:
            # ä¼˜å…ˆçº§emoji
            priority = self._estimate_priority(email)
            emoji = {"high": "ğŸ”´", "medium": "ğŸŸ¡", "low": "âšª"}[priority]
            
            lines.append(
                f"{emoji} {email.sender}: {email.subject}"
            )
            lines.append(f"  {email.preview[:50]}...")
        
        return "\n".join(lines)
    
    def _estimate_priority(self, email):
        """ä¼°ç®—é‚®ä»¶ä¼˜å…ˆçº§"""
        # ç®€å•è§„åˆ™ï¼ˆå¯ç”¨AIå¢å¼ºï¼‰
        if "urgent" in email.subject.lower() or "asap" in email.subject.lower():
            return "high"
        if email.is_starred or email.is_important:
            return "high"
        if "@boss.com" in email.sender:
            return "high"
        return "medium"
    
    def _format_tasks(self, tasks):
        """æ ¼å¼åŒ–ä»»åŠ¡åˆ—è¡¨"""
        if not tasks:
            return "âœ… **ä»Šæ—¥ä»»åŠ¡**: æ— "
        
        lines = ["âœ… **ä»Šæ—¥ä»»åŠ¡**:"]
        
        for task in tasks:
            priority_emoji = {
                1: "ğŸ”´",  # P1
                2: "ğŸŸ¡",  # P2
                3: "âšª",  # P3
                4: "âšª"   # P4
            }.get(task.priority, "âšª")
            
            overdue_mark = " (é€¾æœŸ)" if task.is_overdue else ""
            
            lines.append(
                f"{priority_emoji} {task.content}{overdue_mark}"
            )
            if task.due:
                lines.append(f"  â° {task.due.strftime('%H:%M')}")
        
        return "\n".join(lines)
    
    def _format_system(self, services):
        """æ ¼å¼åŒ–ç³»ç»ŸçŠ¶æ€"""
        lines = ["ğŸ–¥ï¸ **ç³»ç»ŸçŠ¶æ€**:"]
        
        for service in services:
            emoji = "âœ…" if service.status == "up" else "âŒ"
            lines.append(f"{emoji} {service.name}: {service.status}")
        
        # å¦‚æœæœ‰å¤±è´¥çš„GitHub Actions
        failed_workflows = self._get_failed_workflows()
        if failed_workflows:
            lines.append("\nâš ï¸ GitHub Actionså¤±è´¥:")
            for w in failed_workflows:
                lines.append(f"  âŒ {w.name} ({w.repo})")
        
        return "\n".join(lines)
    
    def _assemble_briefing(self, sections):
        """ç»„è£…å®Œæ•´çš„briefingæ¶ˆæ¯"""
        now = datetime.now()
        header = f"""ğŸŒ… **Morning Briefing**
ğŸ“… {now.strftime('%Yå¹´%mæœˆ%dæ—¥ %A')}

"""
        return header + "\n\n".join(sections)

# Croné…ç½®
if __name__ == "__main__":
    agent = MorningBriefingAgent()
    openclaw.run(agent.run())
```

> ğŸ”§ **é‡åˆ°é”™è¯¯ï¼ŸAIèƒ½å¸®ä½ **  
> è¿è¡Œæ—¶çœ‹åˆ°"ModuleNotFoundError"ï¼ŸæŠŠé”™è¯¯ä¿¡æ¯å¤åˆ¶ç»™ChatGPTï¼š  
> "æˆ‘è¿è¡ŒMorning Briefing Agentæ—¶é‡åˆ°ï¼š[ç²˜è´´é”™è¯¯]ï¼Œè¿™æ˜¯ä»€ä¹ˆé—®é¢˜ï¼Ÿå¦‚ä½•è§£å†³ï¼Ÿ"  
> AIé€šå¸¸ä¼šå‘Šè¯‰ä½ ç¼ºå°‘å“ªä¸ªä¾èµ–ï¼Œä»¥åŠå¦‚ä½•å®‰è£…ã€‚

#### æ­¥éª¤4ï¼šé…ç½®Cronå®šæ—¶ä»»åŠ¡

åœ¨`workspace/cron.yaml`ï¼š

```yaml
jobs:
  - name: morning-briefing
    schedule: "0 8 * * *"  # æ¯å¤©æ—©æ™¨8ç‚¹
    command: python agents/morning-briefing.py
    timezone: Asia/Tokyo
    enabled: true
```

å¯åŠ¨ï¼š
```bash
openclaw cron enable morning-briefing
```

#### æ­¥éª¤5ï¼šé¦–æ¬¡æµ‹è¯•ä¸è°ƒä¼˜

ä¸è¦ç­‰åˆ°æ˜å¤©æ—©æ™¨ï¼ç°åœ¨å°±æµ‹è¯•ï¼š

```bash
# æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡
python workspace/agents/morning-briefing.py
```

**ä½ å¯èƒ½ä¼šå‘ç°çš„é—®é¢˜**ï¼š
1. **é‚®ä»¶å¤ªå¤š**ï¼šAIè¿‡æ»¤ä¸å¤Ÿå‡†ç¡® â†’ è°ƒæ•´promptï¼Œå¢åŠ ç¤ºä¾‹
2. **æ—¥å†æ—¶é—´æ˜¾ç¤ºä¸å‹å¥½**ï¼š"è¿˜æœ‰7320ç§’" â†’ æ”¹ä¸º"è¿˜æœ‰2å°æ—¶5åˆ†"
3. **ç³»ç»ŸçŠ¶æ€å¤ªå†—é•¿**ï¼šåªæ˜¾ç¤ºå¤±è´¥çš„æœåŠ¡
4. **æ¶ˆæ¯å¤ªé•¿**ï¼šç§»é™¤ä¸é‡è¦çš„section

**æŒç»­ä¼˜åŒ–**ï¼š
- ç¬¬1å‘¨ï¼šè§‚å¯Ÿå“ªäº›sectionæ¯å¤©éƒ½çœ‹
- ç¬¬2å‘¨ï¼šç§»é™¤ä¸çœ‹çš„ï¼Œå¢åŠ ç¼ºå¤±çš„
- ç¬¬1ä¸ªæœˆï¼šè®©AIå­¦ä¹ ä½ çš„ä¼˜å…ˆçº§ï¼ˆåå¥½å­¦ä¹ ï¼‰

---

### 10.1.3 æ¡ˆä¾‹2ï¼šEmail Triage - æ”¶ä»¶ç®±æ¸…é›¶è‡ªåŠ¨åŒ–[^inbox-declutter-ch10]

[^inbox-declutter-ch10]: æ¡ˆä¾‹æ¥æºï¼š[Inbox De-clutter](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/inbox-declutter.md)ï¼Œawesome-openclaw-usecases ç¤¾åŒºè´¡çŒ®

**ç°çŠ¶é—®é¢˜**ï¼š
- **é‚®ä»¶å †ç§¯**ï¼š200å°æœªè¯»ï¼Œä¸€åŠæ˜¯Newsletter
- **é‡è¦é‚®ä»¶è¢«æ·¹æ²¡**ï¼šå®¢æˆ·çš„ç´§æ€¥è¯·æ±‚åŸ‹åœ¨ä¿ƒé”€é‚®ä»¶ä¸‹
- **æ‰‹åŠ¨åˆ†ç±»è€—æ—¶**ï¼šæ¯å¤©30åˆ†é’Ÿæ ‡è®°ã€å½’æ¡£

**è‡ªåŠ¨åŒ–ç›®æ ‡**ï¼š
- **è‡ªåŠ¨åˆ†ç±»**ï¼šå·¥ä½œ/ä¸ªäºº/Newsletter/ä¿ƒé”€/ç¤¾äº¤
- **è‡ªåŠ¨æ ‡è®°**ï¼šğŸ”´ç´§æ€¥ã€â­é‡è¦ã€ğŸ“‹å¾…åŠ
- **è‡ªåŠ¨å½’æ¡£**ï¼šå·²è¯»çš„Newsletterç›´æ¥å½’æ¡£
- **æ‘˜è¦é€šçŸ¥**ï¼šåªé€šçŸ¥çœŸæ­£é‡è¦çš„

#### æ¶æ„è®¾è®¡

```yaml
# Email Triage System
è§¦å‘å™¨: 
  - Heartbeat (æ¯30åˆ†é’Ÿæ£€æŸ¥æ–°é‚®ä»¶)
  - å®æ—¶æ¨é€ (Gmail Push Notification)

æµç¨‹:
  1. è·å–æœªè¯»é‚®ä»¶
  2. AIåˆ†ç±»ï¼ˆå·¥ä½œ/ä¸ªäºº/Newsletter/ä¿ƒé”€/åƒåœ¾ï¼‰
  3. AIè¯„ä¼°ä¼˜å…ˆçº§ï¼ˆç´§æ€¥/é‡è¦/æ™®é€šï¼‰
  4. è‡ªåŠ¨æ‰§è¡ŒåŠ¨ä½œ:
     - æ·»åŠ Gmailæ ‡ç­¾
     - æ ‡æ˜Ÿé‡è¦é‚®ä»¶
     - å½’æ¡£Newsletterï¼ˆå·²è¯»çš„ï¼‰
     - åˆ é™¤åƒåœ¾é‚®ä»¶
  5. æ¨é€é€šçŸ¥ï¼ˆä»…ç´§æ€¥å’Œé‡è¦ï¼‰

è¾“å‡º: Telegramå®æ—¶é€šçŸ¥ + æ¯æ—¥æ‘˜è¦
```

#### å®ç°ä»£ç 

`workspace/agents/email-triage.py`ï¼š

```python
import openclaw
from datetime import datetime, timedelta

class EmailTriageAgent:
    def __init__(self):
        self.gmail = openclaw.skill("gmail")
        self.ai = openclaw.ai
        
        # åˆ†ç±»æ ‡ç­¾
        self.labels = {
            "work": "Work",
            "personal": "Personal",
            "newsletter": "Newsletter",
            "promo": "Promotions",
            "social": "Social",
            "spam": "Spam"
        }
        
    async def run(self):
        """å®šæœŸæ‰§è¡Œçš„Triage"""
        # è·å–æœªåˆ†ç±»çš„é‚®ä»¶
        unprocessed = await self.gmail.search(
            query="-label:processed",
            max_results=50
        )
        
        if not unprocessed:
            return  # æ²¡æœ‰æ–°é‚®ä»¶
        
        # æ‰¹é‡åˆ†ç±»
        classifications = await self._classify_batch(unprocessed)
        
        # æ‰§è¡ŒåŠ¨ä½œ
        actions_log = []
        for email, classification in zip(unprocessed, classifications):
            actions = await self._apply_classification(email, classification)
            actions_log.append({
                "email": email.subject,
                "category": classification["category"],
                "priority": classification["priority"],
                "actions": actions
            })
        
        # å‘é€æ‘˜è¦ï¼ˆä»…é«˜ä¼˜å…ˆçº§ï¼‰
        high_priority = [
            a for a in actions_log 
            if a["priority"] in ["urgent", "important"]
        ]
        
        if high_priority:
            await self._send_notification(high_priority)
        
        # è®°å½•å¤„ç†ç»“æœ
        await self._log_triage(actions_log)
    
    async def _classify_batch(self, emails):
        """æ‰¹é‡åˆ†ç±»é‚®ä»¶"""
        # æ„å»ºæ‰¹é‡prompt
        email_list = []
        for i, email in enumerate(emails):
            email_list.append({
                "id": i,
                "from": email.sender,
                "subject": email.subject,
                "preview": email.preview[:200],
                "has_attachments": len(email.attachments) > 0
            })
        
        prompt = f"""ä½ æ˜¯ä¸€ä¸ªé‚®ä»¶åˆ†ç±»ä¸“å®¶ã€‚å¯¹ä»¥ä¸‹{len(emails)}å°é‚®ä»¶è¿›è¡Œåˆ†ç±»å’Œä¼˜å…ˆçº§è¯„ä¼°ã€‚

åˆ†ç±»ï¼šworkï¼ˆå·¥ä½œï¼‰ã€personalï¼ˆä¸ªäººï¼‰ã€newsletterï¼ˆè®¢é˜…é€šè®¯ï¼‰ã€promoï¼ˆä¿ƒé”€ï¼‰ã€socialï¼ˆç¤¾äº¤ç½‘ç»œé€šçŸ¥ï¼‰ã€spamï¼ˆåƒåœ¾é‚®ä»¶ï¼‰

ä¼˜å…ˆçº§ï¼šurgentï¼ˆç´§æ€¥ï¼‰ã€importantï¼ˆé‡è¦ï¼‰ã€normalï¼ˆæ™®é€šï¼‰ã€lowï¼ˆä½ï¼‰

åˆ¤æ–­æ ‡å‡†ï¼š
- urgent: éœ€è¦24å°æ—¶å†…å›å¤ï¼Œæ¥è‡ªè€æ¿/å®¢æˆ·/é‡è¦åˆä½œä¼™ä¼´
- important: éœ€è¦æœ¬å‘¨å†…å¤„ç†ï¼Œå·¥ä½œç›¸å…³
- normal: å¯ä»¥ç¨åå¤„ç†
- low: Newsletterã€ä¿ƒé”€ã€ç¤¾äº¤é€šçŸ¥

é‚®ä»¶åˆ—è¡¨ï¼š
{self._format_email_list(email_list)}

è¿”å›JSONæ•°ç»„ï¼Œæ¯å°é‚®ä»¶ä¸€ä¸ªå¯¹è±¡ï¼š
[
  {{"id": 0, "category": "work", "priority": "urgent", "reason": "å®¢æˆ·ç´§æ€¥è¯·æ±‚"}},
  {{"id": 1, "category": "newsletter", "priority": "low", "reason": "æŠ€æœ¯è®¢é˜…"}}
]
"""
        
        response = await self.ai.query(prompt, response_format="json")
        
        # è§£æJSON
        import json
        classifications = json.loads(response)
        
        return classifications
    
    async def _apply_classification(self, email, classification):
        """åº”ç”¨åˆ†ç±»ç»“æœ"""
        actions = []
        
        category = classification["category"]
        priority = classification["priority"]
        
        # 1. æ·»åŠ åˆ†ç±»æ ‡ç­¾
        if category in self.labels:
            await self.gmail.add_label(email.id, self.labels[category])
            actions.append(f"æ ‡ç­¾: {self.labels[category]}")
        
        # 2. æ ¹æ®ä¼˜å…ˆçº§å¤„ç†
        if priority == "urgent":
            await self.gmail.star(email.id)
            await self.gmail.mark_important(email.id)
            actions.append("æ ‡æ˜Ÿ + æ ‡è®°ä¸ºé‡è¦")
        elif priority == "important":
            await self.gmail.mark_important(email.id)
            actions.append("æ ‡è®°ä¸ºé‡è¦")
        
        # 3. è‡ªåŠ¨å½’æ¡£
        if category == "newsletter" and email.is_read:
            await self.gmail.archive(email.id)
            actions.append("å½’æ¡£")
        elif category == "promo":
            await self.gmail.archive(email.id)
            actions.append("å½’æ¡£ä¿ƒé”€")
        elif category == "spam":
            await self.gmail.delete(email.id)
            actions.append("åˆ é™¤åƒåœ¾é‚®ä»¶")
        
        # 4. æ ‡è®°ä¸ºå·²å¤„ç†
        await self.gmail.add_label(email.id, "processed")
        
        return actions
    
    async def _send_notification(self, high_priority_emails):
        """å‘é€é«˜ä¼˜å…ˆçº§é‚®ä»¶é€šçŸ¥"""
        lines = ["ğŸ“§ **é‡è¦é‚®ä»¶æé†’**:\n"]
        
        for item in high_priority_emails:
            emoji = "ğŸ”´" if item["priority"] == "urgent" else "â­"
            lines.append(
                f"{emoji} {item['email']}"
            )
            lines.append(f"  åˆ†ç±»: {item['category']} | åŠ¨ä½œ: {', '.join(item['actions'])}")
        
        message = "\n".join(lines)
        
        await openclaw.message.send(
            target="telegram:me",
            text=message
        )
    
    def _format_email_list(self, email_list):
        """æ ¼å¼åŒ–é‚®ä»¶åˆ—è¡¨ä¸ºæ–‡æœ¬"""
        lines = []
        for e in email_list:
            attachment_mark = "ğŸ“" if e["has_attachments"] else ""
            lines.append(
                f"{e['id']}. From: {e['from']} | Subject: {e['subject']} {attachment_mark}"
            )
            lines.append(f"   Preview: {e['preview']}")
        return "\n".join(lines)
    
    async def _log_triage(self, actions_log):
        """è®°å½•å¤„ç†æ—¥å¿—"""
        log_file = f"memory/email-triage-{datetime.now().strftime('%Y-%m-%d')}.json"
        
        import json
        with open(log_file, "a") as f:
            for action in actions_log:
                f.write(json.dumps(action, ensure_ascii=False) + "\n")

# Heartbeaté…ç½®
if __name__ == "__main__":
    agent = EmailTriageAgent()
    openclaw.run(agent.run())
```

#### é…ç½®Heartbeat

åœ¨`workspace/HEARTBEAT.md`ï¼š

```markdown
# Heartbeat Checklist

## Email Triage (æ¯30åˆ†é’Ÿ)
- æ£€æŸ¥æ–°é‚®ä»¶
- è‡ªåŠ¨åˆ†ç±»å’Œæ ‡è®°
- æ¨é€é«˜ä¼˜å…ˆçº§é€šçŸ¥

æœ€åæ£€æŸ¥: [è‡ªåŠ¨æ›´æ–°]
ä¸‹æ¬¡æ£€æŸ¥: 30åˆ†é’Ÿå
```

åœ¨`workspace/heartbeat-config.yaml`ï¼š

```yaml
checks:
  - name: email-triage
    interval: 1800  # 30åˆ†é’Ÿ
    command: python agents/email-triage.py
    enabled: true
```

#### Newsletterä¸“é¡¹å¤„ç†

è®¸å¤šäººè®¢é˜…äº†å¤§é‡Newsletterï¼Œä½†çœŸæ­£è¯»çš„å¾ˆå°‘ã€‚Agentå¯ä»¥ï¼š

```python
class NewsletterManager:
    """Newsletterä¸“é¡¹ç®¡ç†"""
    
    async def process_newsletters(self):
        """å¤„ç†æ‰€æœ‰Newsletter"""
        newsletters = await self.gmail.search(
            query="label:newsletter is:unread"
        )
        
        for newsletter in newsletters:
            # AIç”Ÿæˆæ‘˜è¦
            summary = await self._summarize_newsletter(newsletter)
            
            # å­˜å…¥çŸ¥è¯†åº“
            await openclaw.kb.ingest(
                content=summary,
                metadata={
                    "type": "newsletter",
                    "title": newsletter.subject,
                    "date": newsletter.date,
                    "source": newsletter.sender
                }
            )
            
            # æ ‡è®°ä¸ºå·²è¯»å¹¶å½’æ¡£
            await self.gmail.mark_read(newsletter.id)
            await self.gmail.archive(newsletter.id)
    
    async def _summarize_newsletter(self, newsletter):
        """AIç”ŸæˆNewsletteræ‘˜è¦"""
        prompt = f"""è¯·æ€»ç»“ä»¥ä¸‹Newsletterçš„æ ¸å¿ƒå†…å®¹ï¼ˆ3-5ä¸ªè¦ç‚¹ï¼‰ï¼š

å‘ä»¶äºº: {newsletter.sender}
ä¸»é¢˜: {newsletter.subject}
å†…å®¹:
{newsletter.body[:2000]}

è¿”å›Markdownæ ¼å¼çš„è¦ç‚¹åˆ—è¡¨ã€‚
"""
        
        return await openclaw.ai.query(prompt)
```

è¿™æ ·ï¼Œä½ å¯ä»¥åœ¨éœ€è¦æ—¶æœç´¢çŸ¥è¯†åº“ï¼š"ä¸Šä¸ªæœˆçš„AIæ–°é—»æœ‰æåˆ°GPT-5å—ï¼Ÿ"ï¼Œè€Œä¸æ˜¯ç¿»é˜…å‡ ç™¾å°æœªè¯»é‚®ä»¶ã€‚

> ğŸ“š **æ·±å…¥å­¦ä¹ **ï¼šæƒ³äº†è§£RAGçŸ¥è¯†åº“çš„å®ç°ï¼Ÿå›åˆ°ç¬¬2ç« ã€ŠAgentçš„è®°å¿†ç³»ç»Ÿã€‹ï¼Œæˆ–é—®AIï¼š"ä»€ä¹ˆæ˜¯RAGï¼Ÿå¦‚ä½•å°†Newsletterå†…å®¹å‘é‡åŒ–å¹¶æ£€ç´¢ï¼Ÿ"

---

### 10.1.4 æ¡ˆä¾‹3ï¼šMulti-Channel Assistant - ç»Ÿä¸€æ“ä½œç•Œé¢[^multi-channel-ch10]

[^multi-channel-ch10]: æ¡ˆä¾‹æ¥æºï¼š[Multi-Channel Personal Assistant](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/multi-channel-assistant.md)ï¼Œawesome-openclaw-usecases ç¤¾åŒºè´¡çŒ®

**ç—›ç‚¹**ï¼š
- TelegramèŠå¤©ã€Slackå·¥ä½œã€Emailå®¢æˆ·ã€Todoistä»»åŠ¡â€”â€”4ä¸ªAppåˆ‡æ¥åˆ‡å»
- æƒ³åœ¨Telegramé‡Œåˆ›å»ºTodoistä»»åŠ¡ï¼Ÿéœ€è¦æ‰“å¼€Appï¼Œåˆ‡æ¢ï¼Œè¾“å…¥
- æƒ³åœ¨Slacké‡Œæœç´¢Emailï¼Ÿå¤åˆ¶ç²˜è´´ï¼Œåˆ‡æ¢çª—å£

**è§£å†³æ–¹æ¡ˆ**ï¼šMulti-Channel Assistantè®©ä½ åœ¨**ä¸€ä¸ªç•Œé¢**ï¼ˆä¾‹å¦‚Telegramï¼‰æ“ä½œæ‰€æœ‰ç³»ç»Ÿã€‚

#### å‘½ä»¤è®¾è®¡

åœ¨Telegramé‡Œï¼š

```
/email search å®¢æˆ·æŠ¥ä»·      â†’ æœç´¢Gmail
/email send to:å®¢æˆ·@example.com subject:æŠ¥ä»·å• â†’ å‘é€é‚®ä»¶
/task add æ˜å¤©æäº¤æŠ¥å‘Š p1  â†’ åˆ›å»ºTodoistä»»åŠ¡
/cal today                â†’ æŸ¥çœ‹ä»Šæ—¥æ—¥ç¨‹
/cal add æ˜å¤©ä¸‹åˆ3ç‚¹ ä¼šè®® â†’ æ·»åŠ æ—¥å†äº‹ä»¶
/kb search RAGç³»ç»Ÿè®¾è®¡    â†’ æœç´¢çŸ¥è¯†åº“
```

#### å®ç°

`workspace/agents/multi-channel-assistant.py`ï¼š

```python
import openclaw
import re

class MultiChannelAssistant:
    def __init__(self):
        self.gmail = openclaw.skill("gmail")
        self.todoist = openclaw.skill("todoist")
        self.calendar = openclaw.skill("google-calendar")
        self.kb = openclaw.kb
        
    async def handle_command(self, message):
        """å¤„ç†ç”¨æˆ·å‘½ä»¤"""
        text = message.text
        
        # è§£æå‘½ä»¤
        if text.startswith("/email"):
            return await self._handle_email(text)
        elif text.startswith("/task"):
            return await self._handle_task(text)
        elif text.startswith("/cal"):
            return await self._handle_calendar(text)
        elif text.startswith("/kb"):
            return await self._handle_kb(text)
        else:
            # è‡ªç„¶è¯­è¨€è§£æ
            return await self._handle_natural_language(text)
    
    async def _handle_email(self, command):
        """å¤„ç†é‚®ä»¶å‘½ä»¤"""
        if "search" in command:
            query = command.replace("/email search", "").strip()
            results = await self.gmail.search(query, max_results=5)
            
            response = f"ğŸ” é‚®ä»¶æœç´¢ç»“æœ (å…³é”®è¯: {query}):\n\n"
            for i, email in enumerate(results, 1):
                response += f"{i}. {email.sender}: {email.subject}\n"
                response += f"   {email.date.strftime('%m-%d %H:%M')} | {email.preview[:50]}...\n\n"
            
            return response
        
        elif "send" in command:
            # è§£æå‘ä»¶å‚æ•°
            match = re.search(r'to:(\S+)\s+subject:(.+)', command)
            if match:
                to = match.group(1)
                subject = match.group(2)
                
                # è®©ç”¨æˆ·è¾“å…¥æ­£æ–‡
                return f"è¯·è¾“å…¥é‚®ä»¶æ­£æ–‡ï¼ˆå°†å‘é€ç»™ {to}ï¼‰:"
                # åç»­æ¶ˆæ¯å¤„ç†é‚®ä»¶æ­£æ–‡å¹¶å‘é€
            else:
                return "æ ¼å¼é”™è¯¯ã€‚ç¤ºä¾‹: /email send to:user@example.com subject:æ ‡é¢˜"
    
    async def _handle_task(self, command):
        """å¤„ç†ä»»åŠ¡å‘½ä»¤"""
        if "add" in command:
            # è§£æä»»åŠ¡å†…å®¹
            task_text = command.replace("/task add", "").strip()
            
            # æ£€æµ‹ä¼˜å…ˆçº§
            priority = 4  # é»˜è®¤P4
            if "p1" in task_text.lower():
                priority = 1
                task_text = task_text.replace("p1", "").strip()
            elif "p2" in task_text.lower():
                priority = 2
                task_text = task_text.replace("p2", "").strip()
            
            # æ£€æµ‹æ—¥æœŸ
            due = None
            if "æ˜å¤©" in task_text:
                due = datetime.now() + timedelta(days=1)
            elif "ä¸‹å‘¨" in task_text:
                due = datetime.now() + timedelta(days=7)
            
            # åˆ›å»ºä»»åŠ¡
            task = await self.todoist.create_task(
                content=task_text,
                priority=priority,
                due=due
            )
            
            return f"âœ… ä»»åŠ¡å·²åˆ›å»º: {task.content} (P{priority})"
        
        elif "list" in command or command == "/task":
            # åˆ—å‡ºä»Šæ—¥ä»»åŠ¡
            tasks = await self.todoist.get_tasks(filter="today")
            
            if not tasks:
                return "ğŸ“‹ ä»Šæ—¥æ— ä»»åŠ¡"
            
            response = "ğŸ“‹ **ä»Šæ—¥ä»»åŠ¡**:\n\n"
            for task in tasks:
                priority_emoji = {1: "ğŸ”´", 2: "ğŸŸ¡", 3: "âšª", 4: "âšª"}[task.priority]
                response += f"{priority_emoji} {task.content}\n"
            
            return response
    
    async def _handle_calendar(self, command):
        """å¤„ç†æ—¥å†å‘½ä»¤"""
        if "today" in command:
            # ä»Šæ—¥æ—¥ç¨‹
            events = await self.calendar.get_events(
                start=datetime.now().replace(hour=0, minute=0),
                end=datetime.now().replace(hour=23, minute=59)
            )
            
            if not events:
                return "ğŸ“… ä»Šæ—¥æ— æ—¥ç¨‹å®‰æ’"
            
            response = "ğŸ“… **ä»Šæ—¥æ—¥ç¨‹**:\n\n"
            for event in sorted(events, key=lambda e: e.start):
                time_str = event.start.strftime("%H:%M")
                response += f"{time_str} - {event.summary}\n"
                if event.location:
                    response += f"  ğŸ“ {event.location}\n"
            
            return response
        
        elif "add" in command:
            # è§£æå¹¶æ·»åŠ äº‹ä»¶ï¼ˆç®€å•è‡ªç„¶è¯­è¨€ï¼‰
            event_text = command.replace("/cal add", "").strip()
            
            # ä½¿ç”¨AIè§£ææ—¶é—´
            parsed = await self._parse_event_time(event_text)
            
            event = await self.calendar.create_event(
                summary=parsed["title"],
                start=parsed["start"],
                end=parsed["end"],
                location=parsed.get("location")
            )
            
            return f"ğŸ“… äº‹ä»¶å·²æ·»åŠ : {event.summary} ({parsed['start'].strftime('%m-%d %H:%M')})"
    
    async def _parse_event_time(self, text):
        """AIè§£æäº‹ä»¶æ—¶é—´"""
        prompt = f"""è§£æä»¥ä¸‹è‡ªç„¶è¯­è¨€ä¸ºæ—¥å†äº‹ä»¶ï¼š
"{text}"

ä»Šå¤©æ˜¯ {datetime.now().strftime('%Y-%m-%d %A')}

è¿”å›JSON:
{{
  "title": "äº‹ä»¶æ ‡é¢˜",
  "start": "YYYY-MM-DD HH:MM",
  "end": "YYYY-MM-DD HH:MM",
  "location": "åœ°ç‚¹ï¼ˆå¦‚æœ‰ï¼‰"
}}
"""
        
        response = await openclaw.ai.query(prompt, response_format="json")
        import json
        return json.loads(response)
    
    async def _handle_kb(self, command):
        """å¤„ç†çŸ¥è¯†åº“å‘½ä»¤"""
        if "search" in command:
            query = command.replace("/kb search", "").strip()
            results = await self.kb.search(query, limit=3)
            
            if not results:
                return f"ğŸ” æœªæ‰¾åˆ°å…³äº '{query}' çš„å†…å®¹"
            
            response = f"ğŸ” çŸ¥è¯†åº“æœç´¢ç»“æœ (å…³é”®è¯: {query}):\n\n"
            for i, result in enumerate(results, 1):
                response += f"{i}. {result.metadata.get('title', 'æ— æ ‡é¢˜')}\n"
                response += f"   {result.content[:100]}...\n"
                response += f"   æ¥æº: {result.metadata.get('source', 'æœªçŸ¥')}\n\n"
            
            return response
    
    async def _handle_natural_language(self, text):
        """å¤„ç†è‡ªç„¶è¯­è¨€è¯·æ±‚"""
        # ä½¿ç”¨AIç†è§£æ„å›¾
        prompt = f"""ç”¨æˆ·è¯´: "{text}"

åˆ¤æ–­ç”¨æˆ·æƒ³åšä»€ä¹ˆï¼Œè¿”å›JSON:
{{
  "intent": "email_search | task_create | calendar_check | kb_search | unknown",
  "parameters": {{}}
}}

ç¤ºä¾‹ï¼š
"å¸®æˆ‘æœç´¢å®¢æˆ·çš„é‚®ä»¶" â†’ {{"intent": "email_search", "parameters": {{"query": "å®¢æˆ·"}}}}
"æ˜å¤©æé†’æˆ‘å¼€ä¼š" â†’ {{"intent": "task_create", "parameters": {{"content": "å¼€ä¼š", "due": "æ˜å¤©"}}}}
"""
        
        response = await openclaw.ai.query(prompt, response_format="json")
        import json
        intent_data = json.loads(response)
        
        intent = intent_data["intent"]
        params = intent_data["parameters"]
        
        if intent == "email_search":
            return await self._handle_email(f"/email search {params['query']}")
        elif intent == "task_create":
            return await self._handle_task(f"/task add {params['content']}")
        elif intent == "calendar_check":
            return await self._handle_calendar("/cal today")
        elif intent == "kb_search":
            return await self._handle_kb(f"/kb search {params['query']}")
        else:
            return "æŠ±æ­‰ï¼Œæˆ‘ä¸å¤ªç†è§£ã€‚ä½ å¯ä»¥ä½¿ç”¨ /email, /task, /cal, /kb å‘½ä»¤ï¼Œæˆ–ç›´æ¥å‘Šè¯‰æˆ‘ä½ æƒ³åšä»€ä¹ˆã€‚"

# Telegram Boté›†æˆ
async def main():
    assistant = MultiChannelAssistant()
    
    @openclaw.telegram.on_message
    async def on_message(message):
        response = await assistant.handle_command(message)
        await openclaw.message.send(
            target="telegram:me",
            text=response
        )
    
    await openclaw.telegram.run()

if __name__ == "__main__":
    openclaw.run(main())
```

ç°åœ¨ä½ å¯ä»¥åœ¨Telegramé‡Œå®Œæˆ90%çš„æ—¥å¸¸æ“ä½œï¼Œä¸å†éœ€è¦é¢‘ç¹åˆ‡æ¢Appã€‚

> ğŸ’¡ **AIè¾…åŠ©æç¤º**ï¼šæƒ³æ‰©å±•æ›´å¤šå‘½ä»¤ï¼ˆä¾‹å¦‚æ§åˆ¶æ™ºèƒ½å®¶å±…ï¼‰ï¼Ÿé—®ChatGPTï¼š"å¦‚ä½•ç»™Multi-Channel Assistantæ·»åŠ /lightå‘½ä»¤æ§åˆ¶é£åˆ©æµ¦Hueç¯ï¼Ÿ"AIä¼šç»™å‡ºé›†æˆç¤ºä¾‹ã€‚

---

### 10.1.5 æ¡ˆä¾‹4ï¼šTodoist Task Manager - AIæ¨ç†æ—¥å¿—åŒæ­¥

**ç‹¬ç‰¹åœºæ™¯**ï¼šå½“ä½ è®©Agentè§£å†³å¤æ‚é—®é¢˜æ—¶ï¼ˆä¾‹å¦‚è°ƒè¯•ä»£ç ã€ç ”ç©¶æŠ€æœ¯æ–¹æ¡ˆï¼‰ï¼ŒAgentçš„æ¨ç†è¿‡ç¨‹å¾ˆæœ‰ä»·å€¼ã€‚å¦‚æœèƒ½è‡ªåŠ¨åŒæ­¥åˆ°ä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼Œä½ å°±æœ‰äº†ï¼š
- **å¯è¿½æº¯çš„å†³ç­–å†å²**
- **ä¸‹æ¬¡é‡åˆ°ç±»ä¼¼é—®é¢˜çš„å‚è€ƒ**
- **å›¢é˜Ÿå…±äº«çš„çŸ¥è¯†ç§¯ç´¯**

#### å®ç°

```python
class TodoistTaskManager:
    """å°†Agentæ¨ç†æ—¥å¿—åŒæ­¥åˆ°Todoist"""
    
    def __init__(self):
        self.todoist = openclaw.skill("todoist")
        self.project_id = "AI_Reasoning_Log"
    
    async def log_reasoning(self, task_name, reasoning_steps, outcome):
        """è®°å½•æ¨ç†è¿‡ç¨‹"""
        # åˆ›å»ºä»»åŠ¡
        task = await self.todoist.create_task(
            content=task_name,
            project_id=self.project_id,
            labels=["ai-reasoning"]
        )
        
        # æ·»åŠ æ¨ç†æ­¥éª¤ä½œä¸ºè¯„è®º
        comment_text = "**æ¨ç†è¿‡ç¨‹**:\n\n"
        for i, step in enumerate(reasoning_steps, 1):
            comment_text += f"{i}. {step}\n"
        
        comment_text += f"\n**ç»“æœ**: {outcome}"
        
        await self.todoist.add_comment(
            task_id=task.id,
            content=comment_text
        )
        
        # å¦‚æœæˆåŠŸï¼Œæ ‡è®°ä¸ºå®Œæˆ
        if "æˆåŠŸ" in outcome or "è§£å†³" in outcome:
            await self.todoist.complete_task(task.id)
    
    async def search_similar_problems(self, problem_description):
        """æœç´¢ç±»ä¼¼é—®é¢˜çš„å†å²è§£å†³æ–¹æ¡ˆ"""
        # æœç´¢Todoistä»»åŠ¡
        tasks = await self.todoist.search(
            query=f"label:ai-reasoning {problem_description}"
        )
        
        if not tasks:
            return None
        
        # è·å–æœ€ç›¸å…³çš„ä»»åŠ¡çš„è¯„è®º
        most_relevant = tasks[0]
        comments = await self.todoist.get_comments(most_relevant.id)
        
        return {
            "task": most_relevant.content,
            "solution": comments[0].content if comments else None,
            "date": most_relevant.created_date
        }

# ä½¿ç”¨ç¤ºä¾‹
async def debug_with_history(error_message):
    """è°ƒè¯•æ—¶å…ˆæŸ¥å†å²"""
    task_manager = TodoistTaskManager()
    
    # æœç´¢å†å²ç±»ä¼¼é—®é¢˜
    history = await task_manager.search_similar_problems(error_message)
    
    if history:
        print(f"âœ… æ‰¾åˆ°å†å²è§£å†³æ–¹æ¡ˆ ({history['date']}):")
        print(history['solution'])
        return
    
    # æ²¡æœ‰å†å²ï¼ŒAIæ¨ç†è§£å†³
    print("ğŸ¤” é¦–æ¬¡é‡åˆ°æ­¤é—®é¢˜ï¼ŒAIæ¨ç†ä¸­...")
    reasoning_steps = []
    
    # æ­¥éª¤1ï¼šåˆ†æé”™è¯¯
    analysis = await openclaw.ai.query(f"åˆ†ææ­¤é”™è¯¯ï¼š{error_message}")
    reasoning_steps.append(f"åˆ†æ: {analysis}")
    
    # æ­¥éª¤2ï¼šæå‡ºå‡è®¾
    hypothesis = await openclaw.ai.query(f"åŸºäºåˆ†æ{analysis}ï¼Œå¯èƒ½çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ")
    reasoning_steps.append(f"å‡è®¾: {hypothesis}")
    
    # æ­¥éª¤3ï¼šéªŒè¯å¹¶è§£å†³
    solution = await openclaw.ai.query(f"å¦‚ä½•è§£å†³ï¼š{hypothesis}")
    reasoning_steps.append(f"è§£å†³æ–¹æ¡ˆ: {solution}")
    
    # è®°å½•åˆ°Todoist
    await task_manager.log_reasoning(
        task_name=f"è°ƒè¯•: {error_message[:50]}",
        reasoning_steps=reasoning_steps,
        outcome="å·²è§£å†³"
    )
    
    print(f"âœ… å·²è§£å†³å¹¶è®°å½•åˆ°Todoist")
```

è¿™æ ·ï¼Œä¸‹æ¬¡é‡åˆ°ç±»ä¼¼é”™è¯¯æ—¶ï¼ŒAgentå¯ä»¥ç›´æ¥å¼•ç”¨å†å²è§£å†³æ–¹æ¡ˆï¼Œè€Œä¸æ˜¯é‡æ–°æ¨ç†ã€‚

---

## ğŸ‘¥ 10.2 å¤šäºº/å¤šé¡¹ç›®ç®¡ç†

### 10.2.1 é—®é¢˜çš„å‡ç»´ï¼šä»ä¸ªäººåˆ°å›¢é˜Ÿ

ä¸ªäººç”Ÿäº§åŠ›ç³»ç»Ÿè§£å†³çš„æ˜¯"æˆ‘çš„æ—¶é—´ç®¡ç†"ï¼Œä½†å›¢é˜Ÿé¡¹ç›®ç®¡ç†é¢ä¸´æ–°æŒ‘æˆ˜ï¼š
- **ä¿¡æ¯åŒæ­¥**ï¼š10ä¸ªäººï¼Œæ¯äººæœ‰ä¸åŒçš„è¿›å±•ï¼Œå¦‚ä½•æ±‡æ€»ï¼Ÿ
- **ä¾èµ–ç®¡ç†**ï¼šä»»åŠ¡Aä¾èµ–ä»»åŠ¡Bï¼ŒBé˜»å¡äº†æ€ä¹ˆåŠï¼Ÿ
- **å¹¶è¡Œæ‰§è¡Œ**ï¼š5ä¸ªä»»åŠ¡å¯ä»¥åŒæ—¶åšï¼Œä½†æœ‰3ä¸ªäººï¼Œå¦‚ä½•åˆ†é…ï¼Ÿ
- **çŠ¶æ€å¯è§æ€§**ï¼šé¡¹ç›®ç»ç†æ¯å¤©é—®"è¿›å±•å¦‚ä½•ï¼Ÿ"ï¼Œèƒ½è‡ªåŠ¨æ±‡æŠ¥å—ï¼Ÿ

ä¼ ç»Ÿæ–¹æ¡ˆï¼š
- **Jira/Asana**ï¼šéœ€è¦æ¯ä¸ªäººæ‰‹åŠ¨æ›´æ–°ä»»åŠ¡çŠ¶æ€ï¼ˆå¾ˆå°‘æœ‰äººåšï¼‰
- **æ¯æ—¥ç«™ä¼š**ï¼š15åˆ†é’ŸåŒæ­¥ä¿¡æ¯ï¼Œä½†ç¬¬äºŒå¤©å°±è¿‡æœŸäº†
- **é¡¹ç›®ç»ç†è¿½ç€é—®**ï¼šæ‰“æ–­å¤§å®¶çš„å·¥ä½œæµ

**AI Agentçš„æ–¹æ¡ˆ**ï¼š
- **Autonomous Project Management**ï¼šAIä½œä¸ºé¡¹ç›®ç»ç†ï¼Œä¸»åŠ¨è·Ÿè¸ªã€åè°ƒã€æ±‡æŠ¥
- **STATE.yaml**ï¼šé¡¹ç›®çŠ¶æ€çš„å•ä¸€äº‹å®æ¥æºï¼ˆSingle Source of Truthï¼‰
- **å¤šAgentå¹¶è¡Œ**ï¼šæ¯ä¸ªå­ä»»åŠ¡spawnä¸€ä¸ªAgentï¼Œå¹¶è¡Œæ‰§è¡Œ

æ¥ä¸‹æ¥æˆ‘ä»¬ä»¥**"é‡æ„3ä¸ªRepoçš„è®¤è¯ç³»ç»Ÿ"**ä¸ºä¾‹ï¼Œå®Œæ•´å®æˆ˜Autonomous PMã€‚

---

### 10.2.2 æ¡ˆä¾‹å®æˆ˜ï¼šå¤šRepoé‡æ„é¡¹ç›®

**é¡¹ç›®èƒŒæ™¯**ï¼š
ä½ çš„å…¬å¸æœ‰3ä¸ªRepoï¼ˆWebã€Mobileã€APIï¼‰ï¼Œéƒ½ä½¿ç”¨æ—§çš„JWTè®¤è¯ã€‚ç°åœ¨è¦ç»Ÿä¸€è¿ç§»åˆ°OAuth2 + SSOã€‚

**ä¼ ç»Ÿåšæ³•**ï¼š
1. é¡¹ç›®ç»ç†åˆ›å»ºJira Epicå’Œ20ä¸ªå­ä»»åŠ¡
2. åˆ†é…ç»™3ä¸ªå·¥ç¨‹å¸ˆ
3. æ¯å¤©ç«™ä¼šé—®è¿›å±•
4. æ‰‹åŠ¨æ£€æŸ¥ä¾èµ–ï¼ˆAPIæ”¹å®Œäº†å—ï¼ŸMobileæ‰èƒ½å¼€å§‹ï¼‰
5. æ±‡æ€»è¿›åº¦ç»™è€æ¿

**Agentåšæ³•**ï¼š
1. å®šä¹‰STATE.yamlï¼ˆé¡¹ç›®çŠ¶æ€ï¼‰
2. Spawnä¸€ä¸ªPM Agent
3. PM Agentè‡ªåŠ¨ï¼š
   - åˆ†è§£ä»»åŠ¡
   - Spawn 3ä¸ªWorker Agentsï¼ˆWebã€Mobileã€APIï¼‰
   - ç›‘æ§è¿›åº¦
   - æ£€æµ‹é˜»å¡
   - æ¯æ—¥æ±‡æŠ¥

#### æ­¥éª¤1ï¼šå®šä¹‰STATE.yaml

`projects/auth-refactor/STATE.yaml`ï¼š

```yaml
project:
  name: "OAuth2è®¤è¯é‡æ„"
  goal: "å°†3ä¸ªRepoçš„è®¤è¯ç³»ç»Ÿè¿ç§»åˆ°OAuth2 + SSO"
  deadline: "2026-03-15"
  status: "in_progress"

repos:
  - name: "web-app"
    url: "https://github.com/company/web-app"
    status: "in_progress"
    assigned_agent: "agent-web"
    
  - name: "mobile-app"
    url: "https://github.com/company/mobile-app"
    status: "blocked"
    blocked_by: ["api-server: OAuth2ç«¯ç‚¹"]
    assigned_agent: "agent-mobile"
    
  - name: "api-server"
    url: "https://github.com/company/api-server"
    status: "in_progress"
    assigned_agent: "agent-api"

tasks:
  # API Serverä»»åŠ¡
  - id: "api-1"
    repo: "api-server"
    title: "å®ç°OAuth2æˆæƒç«¯ç‚¹"
    status: "in_progress"
    progress: 60
    assigned_to: "agent-api"
    dependencies: []
    blockers: []
    
  - id: "api-2"
    repo: "api-server"
    title: "å®ç°Tokenåˆ·æ–°é€»è¾‘"
    status: "done"
    progress: 100
    completed_at: "2026-02-18"
    
  - id: "api-3"
    repo: "api-server"
    title: "SSOé›†æˆ(Auth0)"
    status: "in_progress"
    progress: 40
    blockers:
      - "ç­‰å¾…Auth0é…ç½®å®¡æ‰¹"
    
  # Web Appä»»åŠ¡
  - id: "web-1"
    repo: "web-app"
    title: "ç§»é™¤æ—§JWTé€»è¾‘"
    status: "blocked"
    dependencies: ["api-1"]  # éœ€è¦APIå…ˆå®Œæˆ
    
  - id: "web-2"
    repo: "web-app"
    title: "é›†æˆOAuth2 SDK"
    status: "not_started"
    dependencies: ["web-1"]
    
  # Mobile Appä»»åŠ¡
  - id: "mobile-1"
    repo: "mobile-app"
    title: "å®ç°OAuth2ç™»å½•æµç¨‹"
    status: "blocked"
    dependencies: ["api-1"]
    
  - id: "mobile-2"
    repo: "mobile-app"
    title: "æµ‹è¯•Tokenåˆ·æ–°"
    status: "not_started"
    dependencies: ["mobile-1", "api-2"]

daily_updates:
  - date: "2026-02-19"
    summary: |
      - API: OAuth2ç«¯ç‚¹60%å®Œæˆï¼ŒTokenåˆ·æ–°å·²å®Œæˆ
      - Web: ç­‰å¾…APIå®Œæˆ
      - Mobile: ç­‰å¾…APIå®Œæˆ
      - é˜»å¡: Auth0é…ç½®å®¡æ‰¹ï¼ˆå·²å‡çº§ç»™ç»ç†ï¼‰
    
  - date: "2026-02-18"
    summary: |
      - API: å®ŒæˆTokenåˆ·æ–°é€»è¾‘
      - Web: å‡†å¤‡å·¥ä½œå®Œæˆ
      - Mobile: è®¾è®¡è¯„å®¡é€šè¿‡

risks:
  - issue: "Auth0é…ç½®å®¡æ‰¹å»¶è¿Ÿ"
    severity: "high"
    impact: "é˜»å¡SSOé›†æˆ"
    mitigation: "å·²è”ç³»ç»ç†åŠ é€Ÿå®¡æ‰¹"
    
  - issue: "Webå’ŒMobileä¾èµ–API"
    severity: "medium"
    impact: "å¦‚æœAPIå»¶è¿Ÿï¼Œæ•´ä¸ªé¡¹ç›®å»¶è¿Ÿ"
    mitigation: "ä¼˜å…ˆä¿è¯APIè¿›åº¦"

next_actions:
  - "å®ŒæˆAPI OAuth2ç«¯ç‚¹ï¼ˆé¢„è®¡æ˜å¤©ï¼‰"
  - "è§£é™¤Webå’ŒMobileé˜»å¡"
  - "è·Ÿè¿›Auth0å®¡æ‰¹"
```

> ğŸ“š **æ·±å…¥å­¦ä¹ **ï¼šSTATE.yamlçš„è®¾è®¡å“²å­¦æºè‡ªç¬¬5ç« ã€Šå¤šAgentåä½œæ¨¡å¼ã€‹ã€‚æƒ³äº†è§£æ›´å¤šï¼Ÿå›é¡¾5.2èŠ‚"å…±äº«çŠ¶æ€ä¸åŒæ­¥æœºåˆ¶"ï¼Œæˆ–é—®AIï¼š"ä»€ä¹ˆæ˜¯Single Source of Truthï¼Ÿä¸ºä»€ä¹ˆç”¨YAMLè€Œä¸æ˜¯æ•°æ®åº“ï¼Ÿ"

#### æ­¥éª¤2ï¼šSpawn PM Agent

`workspace/agents/autonomous-pm.py`ï¼š

```python
import openclaw
from datetime import datetime
import yaml

class AutonomousPM:
    """è‡ªä¸»é¡¹ç›®ç»ç†Agent"""
    
    def __init__(self, project_dir):
        self.project_dir = project_dir
        self.state_file = f"{project_dir}/STATE.yaml"
        self.state = self._load_state()
        
    def _load_state(self):
        """åŠ è½½é¡¹ç›®çŠ¶æ€"""
        with open(self.state_file, "r") as f:
            return yaml.safe_load(f)
    
    def _save_state(self):
        """ä¿å­˜é¡¹ç›®çŠ¶æ€"""
        with open(self.state_file, "w") as f:
            yaml.dump(self.state, f, allow_unicode=True)
    
    async def run_daily_standup(self):
        """æ¯æ—¥ç«™ä¼šæµç¨‹"""
        print("ğŸƒ å¼€å§‹æ¯æ—¥é¡¹ç›®æ£€æŸ¥...")
        
        # 1. ä»æ¯ä¸ªWorker Agentè·å–è¿›å±•
        updates = await self._gather_updates()
        
        # 2. æ›´æ–°STATE.yaml
        self._update_state(updates)
        
        # 3. æ£€æµ‹é˜»å¡å’Œä¾èµ–
        blockers = self._detect_blockers()
        
        # 4. é‡æ–°åˆ†é…ä»»åŠ¡ï¼ˆå¦‚æœéœ€è¦ï¼‰
        reassignments = await self._optimize_task_allocation()
        
        # 5. ç”Ÿæˆæ—¥æŠ¥
        report = self._generate_daily_report(updates, blockers)
        
        # 6. å‘é€ç»™å›¢é˜Ÿå’Œè€æ¿
        await self._send_report(report)
        
        # 7. é‡‡å–è¡ŒåŠ¨è§£å†³é˜»å¡
        await self._resolve_blockers(blockers)
    
    async def _gather_updates(self):
        """ä»Worker Agentsæ”¶é›†è¿›å±•"""
        updates = []
        
        for repo in self.state["repos"]:
            agent_name = repo["assigned_agent"]
            
            # ä¸Worker Agenté€šä¿¡ï¼ˆé€šè¿‡æ–‡ä»¶æˆ–æ¶ˆæ¯ï¼‰
            agent_state_file = f"{self.project_dir}/{repo['name']}/AGENT_STATE.yaml"
            
            if os.path.exists(agent_state_file):
                with open(agent_state_file, "r") as f:
                    agent_update = yaml.safe_load(f)
                    updates.append(agent_update)
        
        return updates
    
    def _update_state(self, updates):
        """æ ¹æ®è¿›å±•æ›´æ–°STATE.yaml"""
        for update in updates:
            repo_name = update["repo"]
            
            # æ›´æ–°ä»»åŠ¡è¿›åº¦
            for task_update in update.get("tasks", []):
                task_id = task_update["id"]
                
                # æ‰¾åˆ°å¯¹åº”ä»»åŠ¡
                for task in self.state["tasks"]:
                    if task["id"] == task_id:
                        task["status"] = task_update["status"]
                        task["progress"] = task_update["progress"]
                        
                        if task_update["status"] == "done":
                            task["completed_at"] = datetime.now().strftime("%Y-%m-%d")
                        
                        if "blockers" in task_update:
                            task["blockers"] = task_update["blockers"]
        
        # ä¿å­˜
        self._save_state()
    
    def _detect_blockers(self):
        """æ£€æµ‹é˜»å¡çš„ä»»åŠ¡"""
        blockers = []
        
        for task in self.state["tasks"]:
            # æ£€æŸ¥ä¾èµ–æ˜¯å¦å®Œæˆ
            if task["dependencies"]:
                for dep_id in task["dependencies"]:
                    dep_task = self._find_task(dep_id)
                    
                    if dep_task["status"] != "done":
                        blockers.append({
                            "task": task["id"],
                            "title": task["title"],
                            "blocked_by": dep_task["title"],
                            "type": "dependency"
                        })
            
            # æ£€æŸ¥ä¸»åŠ¨æŠ¥å‘Šçš„é˜»å¡
            if task.get("blockers"):
                for blocker_desc in task["blockers"]:
                    blockers.append({
                        "task": task["id"],
                        "title": task["title"],
                        "blocked_by": blocker_desc,
                        "type": "external"
                    })
        
        return blockers
    
    def _find_task(self, task_id):
        """æŸ¥æ‰¾ä»»åŠ¡"""
        for task in self.state["tasks"]:
            if task["id"] == task_id:
                return task
        return None
    
    async def _optimize_task_allocation(self):
        """ä¼˜åŒ–ä»»åŠ¡åˆ†é…"""
        reassignments = []
        
        # æ‰¾å‡ºå¯ä»¥å¼€å§‹ä½†æœªåˆ†é…çš„ä»»åŠ¡
        available_tasks = [
            t for t in self.state["tasks"]
            if t["status"] == "not_started" and not self._is_blocked(t)
        ]
        
        if not available_tasks:
            return reassignments
        
        # æ£€æŸ¥å“ªäº›Worker Agentç©ºé—²
        idle_agents = await self._find_idle_agents()
        
        # åˆ†é…ä»»åŠ¡
        for task in available_tasks[:len(idle_agents)]:
            agent = idle_agents.pop(0)
            task["assigned_to"] = agent
            task["status"] = "ready"
            
            reassignments.append({
                "task": task["id"],
                "agent": agent
            })
        
        if reassignments:
            self._save_state()
        
        return reassignments
    
    def _is_blocked(self, task):
        """åˆ¤æ–­ä»»åŠ¡æ˜¯å¦è¢«é˜»å¡"""
        # æ£€æŸ¥ä¾èµ–
        for dep_id in task.get("dependencies", []):
            dep_task = self._find_task(dep_id)
            if dep_task["status"] != "done":
                return True
        
        # æ£€æŸ¥ä¸»åŠ¨é˜»å¡
        if task.get("blockers"):
            return True
        
        return False
    
    async def _find_idle_agents(self):
        """æ‰¾å‡ºç©ºé—²çš„Worker Agents"""
        idle = []
        
        for repo in self.state["repos"]:
            agent_name = repo["assigned_agent"]
            
            # æ£€æŸ¥è¯¥Agentæ˜¯å¦æœ‰è¿›è¡Œä¸­çš„ä»»åŠ¡
            agent_tasks = [
                t for t in self.state["tasks"]
                if t.get("assigned_to") == agent_name and t["status"] == "in_progress"
            ]
            
            if not agent_tasks:
                idle.append(agent_name)
        
        return idle
    
    def _generate_daily_report(self, updates, blockers):
        """ç”Ÿæˆæ—¥æŠ¥"""
        report = f"""ğŸ“Š **æ¯æ—¥é¡¹ç›®è¿›å±•æŠ¥å‘Š**
é¡¹ç›®: {self.state['project']['name']}
æ—¥æœŸ: {datetime.now().strftime('%Y-%m-%d')}

---

## ğŸ“ˆ æ€»ä½“è¿›åº¦

"""
        # è®¡ç®—æ•´ä½“è¿›åº¦
        total_tasks = len(self.state["tasks"])
        done_tasks = len([t for t in self.state["tasks"] if t["status"] == "done"])
        in_progress = len([t for t in self.state["tasks"] if t["status"] == "in_progress"])
        
        progress_pct = (done_tasks / total_tasks) * 100
        
        report += f"å·²å®Œæˆ: {done_tasks}/{total_tasks} ({progress_pct:.1f}%)\n"
        report += f"è¿›è¡Œä¸­: {in_progress}\n"
        report += f"é˜»å¡: {len(blockers)}\n\n"
        
        # å„Repoè¿›å±•
        report += "## ğŸ“¦ å„Repoè¿›å±•\n\n"
        for repo in self.state["repos"]:
            repo_tasks = [t for t in self.state["tasks"] if t["repo"] == repo["name"]]
            repo_done = len([t for t in repo_tasks if t["status"] == "done"])
            repo_progress = (repo_done / len(repo_tasks)) * 100 if repo_tasks else 0
            
            status_emoji = {
                "done": "âœ…",
                "in_progress": "ğŸƒ",
                "blocked": "ğŸš«"
            }.get(repo["status"], "âšª")
            
            report += f"{status_emoji} **{repo['name']}**: {repo_progress:.0f}%å®Œæˆ\n"
        
        report += "\n"
        
        # é˜»å¡æƒ…å†µ
        if blockers:
            report += "## ğŸš« é˜»å¡ä»»åŠ¡\n\n"
            for blocker in blockers:
                report += f"- {blocker['title']} (è¢«é˜»å¡: {blocker['blocked_by']})\n"
            report += "\n"
        
        # é£é™©
        if self.state.get("risks"):
            report += "## âš ï¸ é£é™©ä¸ç¼“è§£æªæ–½\n\n"
            for risk in self.state["risks"]:
                severity_emoji = {
                    "high": "ğŸ”´",
                    "medium": "ğŸŸ¡",
                    "low": "ğŸŸ¢"
                }.get(risk["severity"], "âšª")
                
                report += f"{severity_emoji} {risk['issue']}\n"
                report += f"  å½±å“: {risk['impact']}\n"
                report += f"  ç¼“è§£: {risk['mitigation']}\n\n"
        
        # ä¸‹ä¸€æ­¥è¡ŒåŠ¨
        if self.state.get("next_actions"):
            report += "## ğŸ¯ ä¸‹ä¸€æ­¥è¡ŒåŠ¨\n\n"
            for action in self.state["next_actions"]:
                report += f"- {action}\n"
        
        return report
    
    async def _send_report(self, report):
        """å‘é€æ—¥æŠ¥"""
        # å‘é€ç»™å›¢é˜Ÿï¼ˆSlackï¼‰
        await openclaw.message.send(
            target="slack:#project-auth-refactor",
            text=report
        )
        
        # å‘é€ç»™è€æ¿ï¼ˆEmailï¼‰
        await openclaw.message.send(
            target="email:boss@company.com",
            subject=f"é¡¹ç›®è¿›å±•æ—¥æŠ¥ - {self.state['project']['name']}",
            text=report
        )
    
    async def _resolve_blockers(self, blockers):
        """å°è¯•è§£å†³é˜»å¡"""
        for blocker in blockers:
            if blocker["type"] == "external":
                # å¤–éƒ¨é˜»å¡ï¼Œå‡çº§æˆ–æé†’
                await self._escalate_blocker(blocker)
            elif blocker["type"] == "dependency":
                # ä¾èµ–é˜»å¡ï¼Œæ£€æŸ¥èƒ½å¦åŠ é€Ÿä¾èµ–ä»»åŠ¡
                await self._accelerate_dependency(blocker)
    
    async def _escalate_blocker(self, blocker):
        """å‡çº§é˜»å¡é—®é¢˜"""
        message = f"""âš ï¸ é˜»å¡å‡çº§

ä»»åŠ¡: {blocker['title']}
é˜»å¡åŸå› : {blocker['blocked_by']}

è¯·ååŠ©è§£å†³ã€‚
"""
        
        # å‘é€ç»™é¡¹ç›®ç»ç†æˆ–ç›¸å…³è´Ÿè´£äºº
        await openclaw.message.send(
            target="slack:@manager",
            text=message
        )
    
    async def _accelerate_dependency(self, blocker):
        """åŠ é€Ÿä¾èµ–ä»»åŠ¡"""
        # æé†’è´Ÿè´£è¯¥ä¾èµ–ä»»åŠ¡çš„Agent
        dep_task_id = blocker["blocked_by"]  # ç®€åŒ–ï¼šå®é™…éœ€è¦è§£æ
        dep_task = self._find_task(dep_task_id)
        
        if dep_task:
            agent_name = dep_task.get("assigned_to")
            
            if agent_name:
                message = f"""â° ä»»åŠ¡åŠ é€Ÿè¯·æ±‚

ä½ çš„ä»»åŠ¡ "{dep_task['title']}" æ­£åœ¨é˜»å¡å…¶ä»–ä»»åŠ¡ã€‚
å½“å‰è¿›åº¦: {dep_task['progress']}%

èƒ½å¦åŠ é€Ÿå®Œæˆï¼Ÿ
"""
                
                # é€šçŸ¥Worker Agent
                await self._notify_worker(agent_name, message)

# Croné…ç½®ï¼šæ¯å¤©æ—©æ™¨9ç‚¹è¿è¡Œ
async def main():
    pm = AutonomousPM("projects/auth-refactor")
    await pm.run_daily_standup()

if __name__ == "__main__":
    openclaw.run(main())
```

#### æ­¥éª¤3ï¼šWorker Agentå®ç°

æ¯ä¸ªRepoæœ‰è‡ªå·±çš„Worker Agentï¼Œè´Ÿè´£æ‰§è¡Œå…·ä½“ä»»åŠ¡ã€‚

`projects/auth-refactor/api-server/worker-agent.py`ï¼š

```python
import openclaw
from datetime import datetime
import yaml

class APIWorkerAgent:
    """API Serverçš„Worker Agent"""
    
    def __init__(self):
        self.repo = "api-server"
        self.repo_path = "~/repos/api-server"
        self.state_file = "AGENT_STATE.yaml"
        
    async def run_task(self, task_id):
        """æ‰§è¡Œä»»åŠ¡"""
        print(f"ğŸƒ Worker Agentå¼€å§‹æ‰§è¡Œä»»åŠ¡: {task_id}")
        
        if task_id == "api-1":
            await self._implement_oauth2_endpoint()
        elif task_id == "api-2":
            await self._implement_token_refresh()
        elif task_id == "api-3":
            await self._integrate_sso()
    
    async def _implement_oauth2_endpoint(self):
        """å®ç°OAuth2ç«¯ç‚¹"""
        steps = [
            "åˆ†æç°æœ‰JWTå®ç°",
            "è®¾è®¡OAuth2ç«¯ç‚¹API",
            "å®ç°/oauth/authorizeç«¯ç‚¹",
            "å®ç°/oauth/tokenç«¯ç‚¹",
            "ç¼–å†™å•å…ƒæµ‹è¯•",
            "æ›´æ–°APIæ–‡æ¡£"
        ]
        
        for i, step in enumerate(steps):
            print(f"  æ­¥éª¤ {i+1}/{len(steps)}: {step}")
            
            # å®é™…æ‰§è¡Œï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
            if "å®ç°" in step:
                # ä½¿ç”¨AIç”Ÿæˆä»£ç 
                code = await openclaw.ai.query(
                    f"ç”Ÿæˆ{step}çš„Node.jsä»£ç ï¼ˆä½¿ç”¨passport-oauth2ï¼‰"
                )
                
                # å†™å…¥æ–‡ä»¶
                await self._write_code(step, code)
            
            # æ›´æ–°è¿›åº¦
            progress = int(((i + 1) / len(steps)) * 100)
            await self._update_progress("api-1", progress, "in_progress")
        
        # å®Œæˆ
        await self._update_progress("api-1", 100, "done")
        print("âœ… OAuth2ç«¯ç‚¹å®ç°å®Œæˆ")
    
    async def _write_code(self, step_name, code):
        """å†™å…¥ä»£ç åˆ°Repo"""
        # åˆ›å»ºåˆ†æ”¯
        await openclaw.exec(
            command=f"cd {self.repo_path} && git checkout -b oauth2-implementation",
            workdir=self.repo_path
        )
        
        # å†™å…¥ä»£ç 
        file_path = self._determine_file_path(step_name)
        with open(f"{self.repo_path}/{file_path}", "w") as f:
            f.write(code)
        
        # Commit
        await openclaw.exec(
            command=f"cd {self.repo_path} && git add . && git commit -m '{step_name}'",
            workdir=self.repo_path
        )
    
    async def _update_progress(self, task_id, progress, status):
        """æ›´æ–°ä»»åŠ¡è¿›åº¦"""
        state = {
            "repo": self.repo,
            "updated_at": datetime.now().isoformat(),
            "tasks": [
                {
                    "id": task_id,
                    "progress": progress,
                    "status": status
                }
            ]
        }
        
        # å†™å…¥AGENT_STATE.yamlï¼ˆPM Agentä¼šè¯»å–ï¼‰
        with open(self.state_file, "w") as f:
            yaml.dump(state, f)
        
        print(f"  è¿›åº¦æ›´æ–°: {progress}% ({status})")

# ç”±PM Agent spawn
if __name__ == "__main__":
    agent = APIWorkerAgent()
    task_id = sys.argv[1] if len(sys.argv) > 1 else "api-1"
    openclaw.run(agent.run_task(task_id))
```

#### æ­¥éª¤4ï¼šPM Agent Spawn Worker Agents

```python
class AutonomousPM:
    # ... (å‰é¢çš„ä»£ç )
    
    async def spawn_worker_agents(self):
        """ä¸ºæ¯ä¸ªRepo spawn Worker Agent"""
        for repo in self.state["repos"]:
            agent_name = repo["assigned_agent"]
            repo_name = repo["name"]
            
            # Spawn subagent
            await openclaw.subagents.spawn(
                name=agent_name,
                script=f"projects/auth-refactor/{repo_name}/worker-agent.py",
                description=f"Worker Agent for {repo_name}"
            )
            
            print(f"âœ… Spawned {agent_name}")
    
    async def assign_tasks_to_workers(self):
        """åˆ†é…ä»»åŠ¡ç»™Worker Agents"""
        for task in self.state["tasks"]:
            if task["status"] == "not_started" and not self._is_blocked(task):
                agent_name = task.get("assigned_to")
                
                if agent_name:
                    # å‘é€ä»»åŠ¡ç»™Worker Agent
                    await openclaw.subagents.steer(
                        target=agent_name,
                        message=f"æ‰§è¡Œä»»åŠ¡: {task['id']}"
                    )
                    
                    # æ›´æ–°çŠ¶æ€
                    task["status"] = "in_progress"
        
        self._save_state()
```

> ğŸ”§ **é‡åˆ°é”™è¯¯ï¼Ÿ** å¦‚æœSpawnå¤±è´¥ï¼Œæ£€æŸ¥ï¼š  
> 1. Worker Agentè„šæœ¬è·¯å¾„æ˜¯å¦æ­£ç¡®  
> 2. æ˜¯å¦æœ‰æ‰§è¡Œæƒé™ï¼ˆ`chmod +x worker-agent.py`ï¼‰  
> 3. æŠŠé”™è¯¯ä¿¡æ¯ç»™AIï¼š"openclaw subagents spawnæŠ¥é”™ï¼š[ç²˜è´´é”™è¯¯]ï¼Œå¦‚ä½•è§£å†³ï¼Ÿ"

---

### 10.2.3 ä¾èµ–ç®¡ç†ä¸é˜»å¡æ£€æµ‹

åœ¨å¤æ‚é¡¹ç›®ä¸­ï¼Œä»»åŠ¡ä¾èµ–æ˜¯å¸¸æ€ã€‚PM Agentéœ€è¦ï¼š
1. **è‡ªåŠ¨æ£€æµ‹ä¾èµ–é˜»å¡**
2. **å¯è§†åŒ–ä¾èµ–å›¾**
3. **å…³é”®è·¯å¾„åˆ†æ**ï¼ˆCritical Path Methodï¼‰

#### ä¾èµ–å›¾ç”Ÿæˆ

```python
def generate_dependency_graph(self):
    """ç”Ÿæˆä¾èµ–å…³ç³»å›¾ï¼ˆMermaidæ ¼å¼ï¼‰"""
    mermaid = "graph TD\n"
    
    for task in self.state["tasks"]:
        task_id = task["id"]
        task_title = task["title"]
        
        # èŠ‚ç‚¹æ ·å¼ï¼ˆæ ¹æ®çŠ¶æ€ï¼‰
        if task["status"] == "done":
            style = ":::done"
        elif task["status"] == "in_progress":
            style = ":::inprogress"
        elif task["status"] == "blocked":
            style = ":::blocked"
        else:
            style = ""
        
        mermaid += f"  {task_id}[\"{task_title}\"]{style}\n"
        
        # ä¾èµ–è¾¹
        for dep_id in task.get("dependencies", []):
            mermaid += f"  {dep_id} --> {task_id}\n"
    
    # æ ·å¼å®šä¹‰
    mermaid += "\n"
    mermaid += "  classDef done fill:#90EE90\n"
    mermaid += "  classDef inprogress fill:#FFD700\n"
    mermaid += "  classDef blocked fill:#FF6347\n"
    
    return mermaid

async def visualize_project(self):
    """å¯è§†åŒ–é¡¹ç›®çŠ¶æ€"""
    graph = self.generate_dependency_graph()
    
    # ä¿å­˜ä¸ºMarkdown
    with open(f"{self.project_dir}/DEPENDENCY_GRAPH.md", "w") as f:
        f.write("# é¡¹ç›®ä¾èµ–å…³ç³»å›¾\n\n")
        f.write("```mermaid\n")
        f.write(graph)
        f.write("```\n")
    
    # å‘é€åˆ°Slack
    await openclaw.message.send(
        target="slack:#project-auth-refactor",
        text="ğŸ“Š é¡¹ç›®ä¾èµ–å…³ç³»å›¾å·²æ›´æ–°",
        attachments=[f"{self.project_dir}/DEPENDENCY_GRAPH.md"]
    )
```

ç°åœ¨å›¢é˜Ÿå¯ä»¥çœ‹åˆ°ï¼š
```mermaid
graph TD
  api-1["å®ç°OAuth2æˆæƒç«¯ç‚¹"]:::inprogress
  api-2["å®ç°Tokenåˆ·æ–°é€»è¾‘"]:::done
  api-3["SSOé›†æˆ(Auth0)"]:::inprogress
  web-1["ç§»é™¤æ—§JWTé€»è¾‘"]:::blocked
  web-2["é›†æˆOAuth2 SDK"]:::notstarted
  mobile-1["å®ç°OAuth2ç™»å½•æµç¨‹"]:::blocked
  mobile-2["æµ‹è¯•Tokenåˆ·æ–°"]:::notstarted
  
  api-1 --> web-1
  web-1 --> web-2
  api-1 --> mobile-1
  mobile-1 --> mobile-2
  api-2 --> mobile-2
  
  classDef done fill:#90EE90
  classDef inprogress fill:#FFD700
  classDef blocked fill:#FF6347
  classDef notstarted fill:#D3D3D3
```

#### å…³é”®è·¯å¾„åˆ†æ

```python
def find_critical_path(self):
    """æ‰¾å‡ºå…³é”®è·¯å¾„ï¼ˆæœ€é•¿ä¾èµ–é“¾ï¼‰"""
    # æ„å»ºä¾èµ–å›¾
    graph = {}
    for task in self.state["tasks"]:
        graph[task["id"]] = {
            "dependencies": task.get("dependencies", []),
            "duration": self._estimate_duration(task)
        }
    
    # æ‹“æ‰‘æ’åº + æœ€é•¿è·¯å¾„
    def longest_path(task_id, memo={}):
        if task_id in memo:
            return memo[task_id]
        
        if not graph[task_id]["dependencies"]:
            return [(task_id, graph[task_id]["duration"])]
        
        max_path = []
        for dep_id in graph[task_id]["dependencies"]:
            path = longest_path(dep_id, memo)
            if len(path) > len(max_path):
                max_path = path
        
        result = max_path + [(task_id, graph[task_id]["duration"])]
        memo[task_id] = result
        return result
    
    # æ‰¾æ‰€æœ‰ç»ˆç«¯ä»»åŠ¡ï¼ˆæ²¡æœ‰è¢«ä¾èµ–çš„ï¼‰
    all_deps = set()
    for task_id in graph:
        all_deps.update(graph[task_id]["dependencies"])
    
    terminal_tasks = [tid for tid in graph if tid not in all_deps]
    
    # æ‰¾æœ€é•¿è·¯å¾„
    critical_path = []
    for terminal_id in terminal_tasks:
        path = longest_path(terminal_id)
        if len(path) > len(critical_path):
            critical_path = path
    
    return critical_path

def _estimate_duration(self, task):
    """ä¼°ç®—ä»»åŠ¡æ—¶é•¿ï¼ˆå¤©ï¼‰"""
    # ç®€å•è§„åˆ™ï¼ˆå¯ç”¨AIå¢å¼ºï¼‰
    if task["status"] == "done":
        return 0
    
    # æ ¹æ®ä»»åŠ¡å¤æ‚åº¦ä¼°ç®—
    complexity_keywords = {
        "å®ç°": 2,
        "é›†æˆ": 3,
        "æµ‹è¯•": 1,
        "ç§»é™¤": 1,
        "è®¾è®¡": 2
    }
    
    for keyword, days in complexity_keywords.items():
        if keyword in task["title"]:
            return days
    
    return 1  # é»˜è®¤1å¤©
```

ç°åœ¨PM Agentå¯ä»¥å‘Šè¯‰ä½ ï¼š"å…³é”®è·¯å¾„æ˜¯ api-1 â†’ web-1 â†’ web-2ï¼Œé¢„è®¡è¿˜éœ€5å¤©ã€‚å…¶ä»–ä»»åŠ¡å¯ä»¥å¹¶è¡Œï¼Œä½†è¿™æ¡è·¯å¾„å†³å®šé¡¹ç›®å®Œæˆæ—¶é—´ã€‚"

---

## ğŸ  10.3 å®¶åº­åä½œåŠ©æ‰‹

### 10.3.1 ä»åŠå…¬å®¤åˆ°å®¶åº­ï¼šä¸åŒçš„åä½œéœ€æ±‚

ä¼ä¸šé¡¹ç›®ç®¡ç†å…³æ³¨æ•ˆç‡å’Œè¿›åº¦ï¼Œå®¶åº­åä½œå…³æ³¨å’Œè°ä¸å¹³è¡¡ï¼š
- **æ—¥ç¨‹å†²çª**ï¼šçˆ¸çˆ¸çš„åŠ ç­ vs å¦ˆå¦ˆçš„ç‘œä¼½è¯¾ vs å­©å­çš„é’¢ç´è¯¾
- **å®¶åŠ¡åˆ†å·¥**ï¼šè°ä»Šå¤©ä¹°èœï¼Ÿè°æ¥å­©å­ï¼Ÿ
- **åº“å­˜ç®¡ç†**ï¼šç‰›å¥¶å¿«æ²¡äº†ï¼ŒAIè‡ªåŠ¨æé†’æˆ–ä¸‹å•
- **å®¢æœå“åº”**ï¼šå®¶åº­ç¾¤æ¶ˆæ¯ã€é‚»å±…è¯·æ±‚ã€å¿«é€’é€šçŸ¥

AI Agentå¯ä»¥æˆä¸ºå®¶åº­çš„"æ•°å­—ç®¡å®¶"ã€‚

---

### 10.3.2 æ¡ˆä¾‹1ï¼šå®¶åº­æ—¥å†èšåˆä¸å†²çªæ£€æµ‹

**åœºæ™¯**ï¼š
- çˆ¸çˆ¸ç”¨Google Calendarï¼ˆå·¥ä½œï¼‰
- å¦ˆå¦ˆç”¨Apple Calendarï¼ˆä¸ªäººï¼‰
- å­©å­çš„å­¦æ ¡æ´»åŠ¨åœ¨å­¦æ ¡App
- å®¶åº­èšä¼šåœ¨WhatsAppç¾¤

**ç—›ç‚¹**ï¼šæ²¡äººçŸ¥é“å…¨å®¶ä¸‹å‘¨çš„å®Œæ•´æ—¥ç¨‹ï¼Œç»å¸¸æ’è½¦ã€‚

#### å®ç°

`workspace/agents/family-calendar.py`ï¼š

```python
import openclaw
from datetime import datetime, timedelta

class FamilyCalendarAgent:
    def __init__(self):
        self.google_cal = openclaw.skill("google-calendar")
        self.apple_cal = openclaw.skill("apple-calendar")
        self.school_api = openclaw.skill("school-app")
        
        self.family_members = {
            "dad": "google:dad@gmail.com",
            "mom": "apple:mom@icloud.com",
            "kid": "school:12345"
        }
    
    async def generate_weekly_view(self):
        """ç”Ÿæˆå…¨å®¶ä¸€å‘¨æ—¥ç¨‹è§†å›¾"""
        start = datetime.now()
        end = start + timedelta(days=7)
        
        # èšåˆæ‰€æœ‰äººçš„æ—¥ç¨‹
        all_events = []
        
        for member, calendar_id in self.family_members.items():
            events = await self._fetch_events(calendar_id, start, end)
            
            for event in events:
                event["member"] = member
                all_events.append(event)
        
        # æŒ‰æ—¶é—´æ’åº
        all_events.sort(key=lambda e: e["start"])
        
        # æ£€æµ‹å†²çª
        conflicts = self._detect_conflicts(all_events)
        
        # ç”Ÿæˆå¯è§†åŒ–
        view = self._generate_view(all_events, conflicts)
        
        # å‘é€åˆ°å®¶åº­ç¾¤
        await openclaw.message.send(
            target="telegram:family_group",
            text=view
        )
    
    async def _fetch_events(self, calendar_id, start, end):
        """è·å–å•ä¸ªæ—¥å†çš„äº‹ä»¶"""
        cal_type, cal_id = calendar_id.split(":")
        
        if cal_type == "google":
            return await self.google_cal.get_events(
                calendar_id=cal_id,
                start=start,
                end=end
            )
        elif cal_type == "apple":
            return await self.apple_cal.get_events(
                calendar_id=cal_id,
                start=start,
                end=end
            )
        elif cal_type == "school":
            return await self.school_api.get_events(
                student_id=cal_id,
                start=start,
                end=end
            )
    
    def _detect_conflicts(self, events):
        """æ£€æµ‹æ—¶é—´å†²çª"""
        conflicts = []
        
        for i, e1 in enumerate(events):
            for e2 in events[i+1:]:
                # æ£€æŸ¥æ˜¯å¦éœ€è¦åŒä¸€ä¸ªå®¶é•¿åœ¨åœº
                if self._requires_same_person(e1, e2):
                    if self._events_overlap(e1, e2):
                        conflicts.append({
                            "event1": e1,
                            "event2": e2,
                            "type": "person_conflict"
                        })
                
                # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨åŒä¸€è¾†è½¦
                if self._requires_car(e1) and self._requires_car(e2):
                    if self._events_overlap_with_travel(e1, e2):
                        conflicts.append({
                            "event1": e1,
                            "event2": e2,
                            "type": "car_conflict"
                        })
        
        return conflicts
    
    def _requires_same_person(self, e1, e2):
        """åˆ¤æ–­ä¸¤ä¸ªäº‹ä»¶æ˜¯å¦éœ€è¦åŒä¸€ä¸ªäºº"""
        # ä¾‹å¦‚ï¼šå­©å­çš„ä¸¤ä¸ªæ´»åŠ¨éƒ½éœ€è¦å®¶é•¿æ¥é€
        if "kid" in [e1["member"], e2["member"]]:
            if e1.get("requires_parent") and e2.get("requires_parent"):
                return True
        return False
    
    def _requires_car(self, event):
        """åˆ¤æ–­äº‹ä»¶æ˜¯å¦éœ€è¦ç”¨è½¦"""
        car_keywords = ["æ¥é€", "drive", "pickup", "å»"]
        return any(kw in event["summary"].lower() for kw in car_keywords)
    
    def _events_overlap_with_travel(self, e1, e2):
        """è€ƒè™‘äº¤é€šæ—¶é—´çš„å†²çªæ£€æµ‹"""
        # è·å–åœ°ç‚¹
        loc1 = e1.get("location")
        loc2 = e2.get("location")
        
        if not loc1 or not loc2:
            return self._events_overlap(e1, e2)
        
        # ä¼°ç®—äº¤é€šæ—¶é—´
        travel_time = self._estimate_travel_time(loc1, loc2)
        
        # æ‰©å±•æ—¶é—´çª—å£
        e1_end_with_travel = e1["end"] + timedelta(minutes=travel_time)
        e2_start = e2["start"]
        
        return e1_end_with_travel > e2_start
    
    def _estimate_travel_time(self, loc1, loc2):
        """ä¼°ç®—äº¤é€šæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰"""
        # ç®€åŒ–ï¼šä½¿ç”¨AIæˆ–åœ°å›¾API
        # è¿™é‡Œç®€å•è¿”å›30åˆ†é’Ÿ
        return 30
    
    def _generate_view(self, events, conflicts):
        """ç”Ÿæˆå¯è§†åŒ–è§†å›¾"""
        view = "ğŸ“… **æœ¬å‘¨å®¶åº­æ—¥ç¨‹**\n\n"
        
        # æŒ‰å¤©åˆ†ç»„
        from collections import defaultdict
        by_day = defaultdict(list)
        
        for event in events:
            day_key = event["start"].strftime("%Y-%m-%d")
            by_day[day_key].append(event)
        
        # ç”Ÿæˆæ¯å¤©çš„è§†å›¾
        for day_key in sorted(by_day.keys()):
            day_events = by_day[day_key]
            day_date = datetime.strptime(day_key, "%Y-%m-%d")
            
            view += f"**{day_date.strftime('%mæœˆ%dæ—¥ %A')}**\n"
            
            for event in sorted(day_events, key=lambda e: e["start"]):
                time_str = event["start"].strftime("%H:%M")
                member_emoji = {
                    "dad": "ğŸ‘¨",
                    "mom": "ğŸ‘©",
                    "kid": "ğŸ‘¦"
                }.get(event["member"], "ğŸ‘¤")
                
                view += f"  {time_str} {member_emoji} {event['summary']}\n"
                
                if event.get("location"):
                    view += f"    ğŸ“ {event['location']}\n"
            
            view += "\n"
        
        # å†²çªè­¦å‘Š
        if conflicts:
            view += "âš ï¸ **æ£€æµ‹åˆ°å†²çª**:\n\n"
            for conflict in conflicts:
                e1 = conflict["event1"]
                e2 = conflict["event2"]
                
                view += f"- {e1['summary']} ({e1['member']}) ä¸ {e2['summary']} ({e2['member']})\n"
                view += f"  å†²çªç±»å‹: {conflict['type']}\n\n"
        
        return view

# Cron: æ¯å‘¨æ—¥æ™šä¸Š8ç‚¹ç”Ÿæˆä¸‹å‘¨è§†å›¾
async def main():
    agent = FamilyCalendarAgent()
    await agent.generate_weekly_view()

if __name__ == "__main__":
    openclaw.run(main())
```

ç°åœ¨æ¯å‘¨æ—¥æ™šä¸Šï¼Œå®¶åº­ç¾¤ä¼šæ”¶åˆ°ï¼š

```
ğŸ“… **æœ¬å‘¨å®¶åº­æ—¥ç¨‹**

**02æœˆ24æ—¥ å‘¨ä¸€**
  09:00 ğŸ‘¨ å›¢é˜Ÿä¼šè®®
    ğŸ“ åŠå…¬å®¤
  15:00 ğŸ‘¦ é’¢ç´è¯¾
    ğŸ“ éŸ³ä¹å­¦æ ¡
  18:30 ğŸ‘© ç‘œä¼½è¯¾
    ğŸ“ å¥èº«æˆ¿

**02æœˆ25æ—¥ å‘¨äºŒ**
  14:00 ğŸ‘¨ å®¢æˆ·ä¼šè®®
    ğŸ“ å’–å•¡å…
  16:00 ğŸ‘¦ è¶³çƒè®­ç»ƒ
    ğŸ“ ä½“è‚²åœº

âš ï¸ **æ£€æµ‹åˆ°å†²çª**:
- é’¢ç´è¯¾ (kid) ä¸ å®¢æˆ·ä¼šè®® (dad)
  å†²çªç±»å‹: person_conflictï¼ˆéƒ½éœ€è¦å¼€è½¦ï¼Œä½†åªæœ‰ä¸€è¾†è½¦ï¼‰
```

å…¨å®¶å¯ä»¥æå‰åè°ƒï¼šå¦ˆå¦ˆä¸‹ç­æ—©ä¸€ç‚¹å»æ¥å­©å­ï¼Œæˆ–è€…çˆ¸çˆ¸æ”¹çº¦å®¢æˆ·ä¼šè®®æ—¶é—´ã€‚

---

### 10.3.3 æ¡ˆä¾‹2ï¼šå®¶åŠ¡åº“å­˜ç®¡ç†

**åœºæ™¯**ï¼š
- ç‰›å¥¶å¿«æ²¡äº†
- æ´—è¡£ç²‰ç”¨å®Œäº†
- å­©å­çš„ç”Ÿæ—¥ç¤¼ç‰©è¿˜æ²¡ä¹°

**ä¼ ç»Ÿåšæ³•**ï¼š
- å¦ˆå¦ˆå‘ç°æ²¡ç‰›å¥¶äº† â†’ åœ¨å®¶åº­ç¾¤è¯´"è°ä»Šå¤©èƒ½ä¹°ç‰›å¥¶ï¼Ÿ"
- çˆ¸çˆ¸å›å¤"æˆ‘ä»Šå¤©åŠ ç­ï¼Œæ˜å¤©å§"
- ç¬¬äºŒå¤©åˆå¿˜äº†

**Agentåšæ³•**ï¼š
- è‡ªåŠ¨æ£€æµ‹åº“å­˜
- è‡ªåŠ¨ç”Ÿæˆè´­ç‰©æ¸…å•
- è‡ªåŠ¨åˆ†é…ï¼ˆè°ä»Šå¤©è·¯è¿‡è¶…å¸‚ï¼‰
- è‡ªåŠ¨æé†’æˆ–ä¸‹å•

#### å®ç°

`workspace/agents/household-inventory.py`ï¼š

```python
import openclaw
from datetime import datetime, timedelta

class HouseholdInventoryAgent:
    def __init__(self):
        self.inventory_file = "memory/household-inventory.yaml"
        self.inventory = self._load_inventory()
        
        self.amazon_api = openclaw.skill("amazon")
        self.supermarket_api = openclaw.skill("supermarket")
    
    def _load_inventory(self):
        """åŠ è½½åº“å­˜"""
        import yaml
        try:
            with open(self.inventory_file, "r") as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            return {"items": []}
    
    def _save_inventory(self):
        """ä¿å­˜åº“å­˜"""
        import yaml
        with open(self.inventory_file, "w") as f:
            yaml.dump(self.inventory, f)
    
    async def check_inventory(self):
        """æ£€æŸ¥åº“å­˜"""
        low_stock = []
        out_of_stock = []
        
        for item in self.inventory["items"]:
            current = item["quantity"]
            threshold = item["threshold"]
            
            if current == 0:
                out_of_stock.append(item)
            elif current <= threshold:
                low_stock.append(item)
        
        if out_of_stock or low_stock:
            await self._handle_low_stock(out_of_stock, low_stock)
    
    async def _handle_low_stock(self, out_of_stock, low_stock):
        """å¤„ç†ä½åº“å­˜"""
        # ç”Ÿæˆè´­ç‰©æ¸…å•
        shopping_list = out_of_stock + low_stock
        
        # æ£€æŸ¥è‡ªåŠ¨è¡¥è´§è®¾ç½®
        auto_order_items = [
            item for item in shopping_list
            if item.get("auto_order", False)
        ]
        
        manual_items = [
            item for item in shopping_list
            if not item.get("auto_order", False)
        ]
        
        # è‡ªåŠ¨ä¸‹å•
        if auto_order_items:
            await self._auto_order(auto_order_items)
        
        # é€šçŸ¥å®¶äººæ‰‹åŠ¨è´­ä¹°
        if manual_items:
            await self._notify_shopping_list(manual_items)
    
    async def _auto_order(self, items):
        """è‡ªåŠ¨ä¸‹å•"""
        for item in items:
            if item["category"] == "grocery":
                # ä½¿ç”¨è¶…å¸‚API
                await self.supermarket_api.add_to_cart(
                    product_id=item["product_id"],
                    quantity=item["reorder_quantity"]
                )
            elif item["category"] == "household":
                # ä½¿ç”¨Amazon
                await self.amazon_api.reorder(
                    asin=item["asin"],
                    quantity=item["reorder_quantity"]
                )
        
        # é€šçŸ¥å·²ä¸‹å•
        message = f"ğŸ›’ è‡ªåŠ¨è¡¥è´§å®Œæˆ:\n"
        for item in items:
            message += f"- {item['name']} x{item['reorder_quantity']}\n"
        
        await openclaw.message.send(
            target="telegram:family_group",
            text=message
        )
    
    async def _notify_shopping_list(self, items):
        """é€šçŸ¥è´­ç‰©æ¸…å•"""
        message = "ğŸ›’ **è´­ç‰©æé†’**:\n\n"
        
        for item in items:
            urgency = "ğŸ”´" if item["quantity"] == 0 else "ğŸŸ¡"
            message += f"{urgency} {item['name']} (å‰©ä½™: {item['quantity']}{item['unit']})\n"
        
        message += "\nè°ä»Šå¤©èƒ½å»ä¹°ï¼Ÿ"
        
        # å‘é€åˆ°å®¶åº­ç¾¤
        await openclaw.message.send(
            target="telegram:family_group",
            text=message
        )
        
        # æ™ºèƒ½åˆ†é…ï¼šæ£€æŸ¥è°ä»Šå¤©è·¯è¿‡è¶…å¸‚
        assignee = await self._suggest_assignee(items)
        
        if assignee:
            message += f"\nğŸ’¡ å»ºè®®ï¼š@{assignee} ä»Šå¤©è·¯è¿‡è¶…å¸‚ï¼Œå¯ä»¥é¡ºä¾¿ä¹°ã€‚"
    
    async def _suggest_assignee(self, items):
        """æ™ºèƒ½åˆ†é…è´­ç‰©ä»»åŠ¡"""
        # è·å–å®¶äººä»Šæ—¥è¡Œç¨‹
        calendar_agent = FamilyCalendarAgent()
        
        for member in ["dad", "mom"]:
            events = await calendar_agent._fetch_events(
                calendar_agent.family_members[member],
                start=datetime.now(),
                end=datetime.now() + timedelta(hours=24)
            )
            
            # æ£€æŸ¥æ˜¯å¦è·¯è¿‡è¶…å¸‚
            for event in events:
                if self._near_supermarket(event.get("location")):
                    return member
        
        return None
    
    def _near_supermarket(self, location):
        """åˆ¤æ–­åœ°ç‚¹æ˜¯å¦é è¿‘è¶…å¸‚"""
        if not location:
            return False
        
        supermarket_keywords = ["è¶…å¸‚", "mall", "shopping"]
        return any(kw in location.lower() for kw in supermarket_keywords)
    
    async def update_inventory(self, item_name, change):
        """æ›´æ–°åº“å­˜ï¼ˆæ¶ˆè´¹æˆ–è¡¥å……ï¼‰"""
        for item in self.inventory["items"]:
            if item["name"] == item_name:
                item["quantity"] += change
                item["last_updated"] = datetime.now().isoformat()
                
                self._save_inventory()
                
                # å¦‚æœä½äºé˜ˆå€¼ï¼Œè§¦å‘æ£€æŸ¥
                if item["quantity"] <= item["threshold"]:
                    await self.check_inventory()
                
                return
    
    async def learn_consumption_pattern(self):
        """å­¦ä¹ æ¶ˆè´¹æ¨¡å¼ï¼Œä¼˜åŒ–é˜ˆå€¼"""
        # åˆ†æå†å²æ•°æ®
        history = self._load_consumption_history()
        
        for item in self.inventory["items"]:
            item_history = [h for h in history if h["item"] == item["name"]]
            
            if len(item_history) < 5:
                continue  # æ•°æ®ä¸è¶³
            
            # è®¡ç®—å¹³å‡æ¶ˆè´¹é€Ÿåº¦
            consumption_rate = self._calculate_consumption_rate(item_history)
            
            # ä¼˜åŒ–é˜ˆå€¼ï¼ˆæå‰Xå¤©è¡¥è´§ï¼‰
            lead_time = item.get("lead_time_days", 3)
            optimal_threshold = consumption_rate * lead_time
            
            # æ›´æ–°
            item["threshold"] = int(optimal_threshold)
            item["consumption_rate"] = consumption_rate
        
        self._save_inventory()

# ä¸å…¶ä»–ç³»ç»Ÿé›†æˆ
async def integrate_with_scanner():
    """ä¸æ¡å½¢ç æ‰«æä»ªé›†æˆ"""
    # ä½¿ç”¨æ‰‹æœºAppæ‰«ææ¡å½¢ç ï¼Œè‡ªåŠ¨æ›´æ–°åº“å­˜
    agent = HouseholdInventoryAgent()
    
    @openclaw.telegram.on_message
    async def on_barcode(message):
        if message.text.startswith("/scan"):
            barcode = message.text.replace("/scan", "").strip()
            
            # è¯†åˆ«å•†å“
            product = await openclaw.api.lookup_barcode(barcode)
            
            # æ›´æ–°åº“å­˜
            await agent.update_inventory(product["name"], change=1)
            
            await openclaw.message.send(
                target="telegram:me",
                text=f"âœ… å·²æ·»åŠ : {product['name']}"
            )

# Heartbeat: æ¯å¤©æ£€æŸ¥ä¸€æ¬¡åº“å­˜
async def main():
    agent = HouseholdInventoryAgent()
    await agent.check_inventory()

if __name__ == "__main__":
    openclaw.run(main())
```

**åº“å­˜é…ç½®æ–‡ä»¶ç¤ºä¾‹** (`memory/household-inventory.yaml`)ï¼š

```yaml
items:
  - name: "ç‰›å¥¶"
    category: "grocery"
    quantity: 2  # å‰©ä½™2ç“¶
    unit: "ç“¶"
    threshold: 1  # å‰©ä½™1ç“¶æ—¶æé†’
    reorder_quantity: 4
    auto_order: true
    product_id: "supermarket-12345"
    last_updated: "2026-02-19T10:00:00"
    
  - name: "æ´—è¡£ç²‰"
    category: "household"
    quantity: 0  # ç”¨å®Œäº†
    unit: "è¢‹"
    threshold: 1
    reorder_quantity: 2
    auto_order: true
    asin: "B08XYZ1234"
    
  - name: "å«ç”Ÿçº¸"
    category: "household"
    quantity: 8
    unit: "å·"
    threshold: 4
    reorder_quantity: 12
    auto_order: false  # æ‰‹åŠ¨è´­ä¹°ï¼ˆä»·æ ¼æ³¢åŠ¨å¤§ï¼‰
    
  - name: "é¸¡è›‹"
    category: "grocery"
    quantity: 6
    unit: "ä¸ª"
    threshold: 6
    reorder_quantity: 12
    auto_order: false
    consumption_rate: 2  # æ¯å¤©æ¶ˆè´¹2ä¸ª
    lead_time_days: 2  # éœ€è¦æå‰2å¤©è¡¥è´§
```

---

### 10.3.4 æ¡ˆä¾‹3ï¼šMulti-Channel Customer Service - å®¶åº­å®¢æœä¸­å¿ƒ

**åœºæ™¯**ï¼š
å®¶åº­ä¹Ÿæœ‰"å®¢æœ"éœ€æ±‚ï¼š
- **WhatsApp**ï¼šé‚»å±…å€Ÿå·¥å…·ã€ç‰©ä¸šé€šçŸ¥
- **Instagram DM**ï¼šå­©å­å­¦æ ¡å®¶é•¿ç¾¤
- **Email**ï¼šè´¦å•ã€è®¢é˜…ç»­è´¹æé†’
- **Googleè¯„è®º**ï¼šä½ çš„å‰¯ä¸šå•†åº—çš„å®¢æˆ·è¯„ä»·

**ç—›ç‚¹**ï¼š
æ¯ä¸ªæ¸ é“å•ç‹¬å¤„ç†ï¼Œå›å¤æ…¢ã€å®¹æ˜“é—æ¼ã€‚

**Agentæ–¹æ¡ˆ**ï¼š
ç»Ÿä¸€å…¥å£ï¼Œè‡ªåŠ¨åˆ†ç±»ã€æ™ºèƒ½å›å¤ã€è·Ÿè¸ªå¾…åŠã€‚

#### å®ç°

`workspace/agents/multi-channel-customer-service.py`ï¼š

```python
import openclaw
from datetime import datetime

class MultiChannelCustomerService:
    def __init__(self):
        self.channels = {
            "whatsapp": openclaw.skill("whatsapp"),
            "instagram": openclaw.skill("instagram"),
            "email": openclaw.skill("gmail"),
            "reviews": openclaw.skill("google-reviews")
        }
        
        self.state_file = "memory/customer-service-state.yaml"
    
    async def monitor_all_channels(self):
        """ç›‘æ§æ‰€æœ‰æ¸ é“çš„æ–°æ¶ˆæ¯"""
        new_messages = []
        
        for channel_name, channel_skill in self.channels.items():
            messages = await self._fetch_new_messages(channel_name, channel_skill)
            
            for msg in messages:
                msg["channel"] = channel_name
                new_messages.append(msg)
        
        # å¤„ç†æ¯æ¡æ¶ˆæ¯
        for msg in new_messages:
            await self._handle_message(msg)
    
    async def _fetch_new_messages(self, channel_name, channel_skill):
        """è·å–å•ä¸ªæ¸ é“çš„æ–°æ¶ˆæ¯"""
        if channel_name == "whatsapp":
            return await channel_skill.get_unread_messages()
        elif channel_name == "instagram":
            return await channel_skill.get_dm()
        elif channel_name == "email":
            return await channel_skill.search("is:unread label:customer-service")
        elif channel_name == "reviews":
            return await channel_skill.get_unanswered_reviews()
    
    async def _handle_message(self, msg):
        """å¤„ç†å•æ¡æ¶ˆæ¯"""
        # 1. AIåˆ†ç±»
        classification = await self._classify_message(msg)
        
        # 2. æ ¹æ®åˆ†ç±»é‡‡å–è¡ŒåŠ¨
        if classification["type"] == "urgent":
            await self._handle_urgent(msg, classification)
        elif classification["type"] == "auto_reply":
            await self._auto_reply(msg, classification)
        elif classification["type"] == "needs_human":
            await self._escalate_to_human(msg, classification)
        elif classification["type"] == "informational":
            await self._log_info(msg)
    
    async def _classify_message(self, msg):
        """AIåˆ†ç±»æ¶ˆæ¯"""
        prompt = f"""åˆ†ç±»ä»¥ä¸‹æ¶ˆæ¯ï¼š

æ¥æº: {msg['channel']}
å‘ä»¶äºº: {msg['sender']}
å†…å®¹: {msg['content']}

åˆ†ç±»ï¼š
- urgentï¼ˆç´§æ€¥ï¼Œéœ€è¦ç«‹å³å›å¤ï¼‰
- auto_replyï¼ˆå¯ä»¥è‡ªåŠ¨å›å¤ï¼‰
- needs_humanï¼ˆéœ€è¦äººå·¥å¤„ç†ï¼‰
- informationalï¼ˆä»…ä¿¡æ¯ï¼Œæ— éœ€å›å¤ï¼‰

è¿”å›JSON:
{{
  "type": "urgent | auto_reply | needs_human | informational",
  "reason": "åˆ†ç±»åŸå› ",
  "suggested_reply": "å»ºè®®å›å¤å†…å®¹ï¼ˆå¦‚æœæ˜¯auto_replyï¼‰"
}}
"""
        
        response = await openclaw.ai.query(prompt, response_format="json")
        import json
        return json.loads(response)
    
    async def _handle_urgent(self, msg, classification):
        """å¤„ç†ç´§æ€¥æ¶ˆæ¯"""
        # ç«‹å³é€šçŸ¥å®¶äºº
        alert = f"""ğŸš¨ **ç´§æ€¥æ¶ˆæ¯**

æ¥æº: {msg['channel']}
å‘ä»¶äºº: {msg['sender']}
å†…å®¹: {msg['content']}

åŸå› : {classification['reason']}

è¯·å°½å¿«å›å¤ï¼
"""
        
        await openclaw.message.send(
            target="telegram:family_group",
            text=alert
        )
    
    async def _auto_reply(self, msg, classification):
        """è‡ªåŠ¨å›å¤"""
        reply_text = classification["suggested_reply"]
        
        # å‘é€å›å¤
        channel = self.channels[msg["channel"]]
        await channel.send_message(
            to=msg["sender"],
            text=reply_text
        )
        
        # è®°å½•æ—¥å¿—
        await self._log_interaction(msg, reply_text, auto=True)
    
    async def _escalate_to_human(self, msg, classification):
        """å‡çº§ç»™äººå·¥"""
        notification = f"""ğŸ“¬ **éœ€è¦å›å¤**

æ¥æº: {msg['channel']}
å‘ä»¶äºº: {msg['sender']}
å†…å®¹: {msg['content']}

åŸå› : {classification['reason']}

è¯·åœ¨æ­¤å›å¤ï¼Œæˆ‘ä¼šè½¬å‘ã€‚
"""
        
        # å‘é€åˆ°å®¶åº­ç¾¤
        reply = await openclaw.message.send_and_wait_reply(
            target="telegram:family_group",
            text=notification,
            timeout=3600  # 1å°æ—¶å†…å›å¤
        )
        
        # è½¬å‘å›å¤
        if reply:
            channel = self.channels[msg["channel"]]
            await channel.send_message(
                to=msg["sender"],
                text=reply.text
            )
            
            await self._log_interaction(msg, reply.text, auto=False)
        else:
            # è¶…æ—¶æœªå›å¤ï¼Œå‘é€é»˜è®¤æ¶ˆæ¯
            await self._send_timeout_reply(msg)
    
    async def _log_info(self, msg):
        """è®°å½•ä¿¡æ¯ç±»æ¶ˆæ¯"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "channel": msg["channel"],
            "sender": msg["sender"],
            "content": msg["content"],
            "type": "informational"
        }
        
        # ä¿å­˜åˆ°æ—¥å¿—
        await self._append_log(log_entry)
    
    async def _log_interaction(self, msg, reply, auto):
        """è®°å½•äº’åŠ¨æ—¥å¿—"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "channel": msg["channel"],
            "sender": msg["sender"],
            "message": msg["content"],
            "reply": reply,
            "auto_reply": auto
        }
        
        await self._append_log(log_entry)
    
    async def generate_weekly_report(self):
        """ç”Ÿæˆæ¯å‘¨å®¢æœæŠ¥å‘Š"""
        logs = await self._load_logs(days=7)
        
        # ç»Ÿè®¡
        total_messages = len(logs)
        auto_replies = len([l for l in logs if l.get("auto_reply")])
        human_replies = len([l for l in logs if l.get("auto_reply") == False])
        
        by_channel = {}
        for log in logs:
            channel = log["channel"]
            by_channel[channel] = by_channel.get(channel, 0) + 1
        
        # ç”ŸæˆæŠ¥å‘Š
        report = f"""ğŸ“Š **æ¯å‘¨å®¢æœæŠ¥å‘Š**

æ€»æ¶ˆæ¯æ•°: {total_messages}
è‡ªåŠ¨å›å¤: {auto_replies} ({auto_replies/total_messages*100:.1f}%)
äººå·¥å›å¤: {human_replies} ({human_replies/total_messages*100:.1f}%)

å„æ¸ é“åˆ†å¸ƒ:
"""
        
        for channel, count in sorted(by_channel.items(), key=lambda x: x[1], reverse=True):
            report += f"  {channel}: {count} ({count/total_messages*100:.1f}%)\n"
        
        # å‘é€æŠ¥å‘Š
        await openclaw.message.send(
            target="telegram:family_group",
            text=report
        )

# Heartbeat: æ¯15åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
async def main():
    agent = MultiChannelCustomerService()
    await agent.monitor_all_channels()

if __name__ == "__main__":
    openclaw.run(main())
```

ç°åœ¨ï¼Œæ— è®ºæ˜¯WhatsAppçš„é‚»å±…å€Ÿå·¥å…·è¯·æ±‚ï¼Œè¿˜æ˜¯Instagramçš„å®¶é•¿ç¾¤æ¶ˆæ¯ï¼ŒAgentéƒ½ä¼šï¼š
1. è‡ªåŠ¨åˆ†ç±»
2. èƒ½è‡ªåŠ¨å›å¤çš„ç«‹å³å›å¤ï¼ˆä¾‹å¦‚"å·¥å…·åœ¨è½¦åº“ï¼Œé’¥åŒ™åœ¨é—¨å«ä¸‹"ï¼‰
3. éœ€è¦äººå·¥å¤„ç†çš„ï¼Œåœ¨å®¶åº­ç¾¤è¯¢é—®å¹¶è½¬å‘å›å¤
4. æ¯å‘¨ç”ŸæˆæŠ¥å‘Šï¼Œäº†è§£å®¢æœè´Ÿæ‹…

> ğŸ’¡ **AIè¾…åŠ©æç¤º**ï¼šæƒ³æ‰©å±•åˆ°æ›´å¤šæ¸ é“ï¼ˆDiscordã€Twitter DMï¼‰ï¼Ÿé—®ChatGPTï¼š"å¦‚ä½•ç»™Multi-Channel Customer Serviceæ·»åŠ Discordé›†æˆï¼Ÿéœ€è¦å“ªäº›APIï¼Ÿ"

---

## ğŸ“Œ 10.4 ç« èŠ‚æ€»ç»“ä¸æœ€ä½³å®è·µ

### 10.4.1 æˆ‘ä»¬å­¦åˆ°äº†ä»€ä¹ˆ

æœ¬ç« é€šè¿‡7ä¸ªå®Œæ•´æ¡ˆä¾‹ï¼Œå±•ç¤ºäº†AI Agentåœ¨ç”Ÿäº§åŠ›å’Œé¡¹ç›®ç®¡ç†ä¸­çš„åº”ç”¨ï¼š

**ä¸ªäººç”Ÿäº§åŠ›ç³»ç»Ÿ**ï¼š
- **Morning Briefing**ï¼šä¸»åŠ¨èšåˆä¿¡æ¯ï¼Œé¿å…è¢«åŠ¨æŸ¥çœ‹
- **Email Triage**ï¼šè‡ªåŠ¨åˆ†ç±»å’Œè¿‡æ»¤ï¼Œæ”¶ä»¶ç®±æ¸…é›¶
- **Multi-Channel Assistant**ï¼šç»Ÿä¸€æ“ä½œç•Œé¢ï¼Œå‡å°‘åˆ‡æ¢
- **Todoist Task Manager**ï¼šæ¨ç†æ—¥å¿—åŒæ­¥ï¼ŒçŸ¥è¯†ç§¯ç´¯

**å¤šäºº/å¤šé¡¹ç›®ç®¡ç†**ï¼š
- **Autonomous PM**ï¼šAIä½œä¸ºé¡¹ç›®ç»ç†ï¼Œè‡ªä¸»è·Ÿè¸ªå’Œåè°ƒ
- **STATE.yaml**ï¼šé¡¹ç›®çŠ¶æ€çš„å•ä¸€äº‹å®æ¥æº
- **ä¾èµ–ç®¡ç†**ï¼šè‡ªåŠ¨æ£€æµ‹é˜»å¡ï¼Œä¼˜åŒ–å…³é”®è·¯å¾„

**å®¶åº­åä½œåŠ©æ‰‹**ï¼š
- **å®¶åº­æ—¥å†èšåˆ**ï¼šå…¨å®¶æ—¥ç¨‹å¯è§ï¼Œå†²çªæ£€æµ‹
- **åº“å­˜ç®¡ç†**ï¼šè‡ªåŠ¨è¡¥è´§ï¼Œæ™ºèƒ½åˆ†é…è´­ç‰©ä»»åŠ¡
- **Multi-Channelå®¢æœ**ï¼šç»Ÿä¸€å¤„ç†å¤šæ¸ é“æ¶ˆæ¯

### 10.4.2 è®¾è®¡åŸåˆ™å›é¡¾

**1. ä¸»åŠ¨ > è¢«åŠ¨**
ä¸è¦ç­‰ç”¨æˆ·æ¥æŸ¥è¯¢ï¼Œä¸»åŠ¨æ¨é€å…³é”®ä¿¡æ¯ã€‚Morning Briefingæ¯å¤©æ—©æ™¨æ±‡æŠ¥ï¼Œè€Œä¸æ˜¯ç­‰ä½ æ‰“å¼€5ä¸ªAppã€‚

**2. èšåˆ > åˆ†æ•£**
å°†åˆ†æ•£çš„ç³»ç»Ÿæ•´åˆåˆ°ä¸€ä¸ªç•Œé¢ã€‚Multi-Channel Assistantè®©ä½ åœ¨Telegramæ“ä½œæ‰€æœ‰ç³»ç»Ÿã€‚

**3. è‡ªåŠ¨åŒ– > æ‰‹åŠ¨**
èƒ½è‡ªåŠ¨å®Œæˆçš„ä¸è¦è®©äººåšã€‚Email Triageè‡ªåŠ¨åˆ†ç±»å½’æ¡£ï¼Œè€Œä¸æ˜¯è®©ä½ æ‰‹åŠ¨æ ‡è®°200å°é‚®ä»¶ã€‚

**4. å¯è§‚æµ‹ > é»‘ç›’**
çŠ¶æ€è¦å¯è§ã€å¯å®¡è®¡ã€‚STATE.yamlè®©é¡¹ç›®è¿›å±•ä¸€ç›®äº†ç„¶ï¼Œä¸éœ€è¦è¿½ç€äººé—®ã€‚

**5. æ¸è¿›å¼è‡ªåŠ¨åŒ–**
ä»Level 1ï¼ˆèšåˆä¿¡æ¯ï¼‰å¼€å§‹ï¼Œé€æ­¥æå‡åˆ°Level 3-4ï¼ˆè‡ªåŠ¨æ‰§è¡Œï¼‰ã€‚ä¸è¦ä¸€å¼€å§‹å°±å®Œå…¨è‡ªä¸»ï¼Œé£é™©å¤ªé«˜ã€‚

### 10.4.3 å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•

**é™·é˜±1ï¼šè¿‡åº¦è‡ªåŠ¨åŒ–**
âŒ é—®é¢˜ï¼šAgentè‡ªåŠ¨å›å¤å®¢æˆ·é‚®ä»¶ï¼Œç»“æœè¯´é”™è¯ï¼ŒæŸå¤±å®¢æˆ·ã€‚  
âœ… è§£å†³ï¼šé‡è¦æ¶ˆæ¯å…ˆé€šçŸ¥äººå·¥ç¡®è®¤ï¼Œå†å‘é€ã€‚è®¾ç½®"å®‰å…¨æ¨¡å¼"ã€‚

**é™·é˜±2ï¼šä¿¡æ¯è¿‡è½½**
âŒ é—®é¢˜ï¼šMorning BriefingåŒ…å«50æ¡ä¿¡æ¯ï¼Œçœ‹ä¸è¿‡æ¥ã€‚  
âœ… è§£å†³ï¼šAIè¿‡æ»¤ï¼Œåªä¿ç•™æœ€é‡è¦çš„5æ¡ã€‚å…¶ä»–çš„å­˜å…¥çŸ¥è¯†åº“ï¼Œéœ€è¦æ—¶æœç´¢ã€‚

**é™·é˜±3ï¼šå•ç‚¹æ•…éšœ**
âŒ é—®é¢˜ï¼šPM AgentæŒ‚äº†ï¼Œæ•´ä¸ªé¡¹ç›®åœæ»ã€‚  
âœ… è§£å†³ï¼šSTATE.yamlæ˜¯å•ä¸€äº‹å®æ¥æºï¼Œå³ä½¿PM AgentæŒ‚äº†ï¼Œä¹Ÿå¯ä»¥æ‰‹åŠ¨æ¥ç®¡æˆ–é‡æ–°spawnã€‚

**é™·é˜±4ï¼šå¿½è§†äººçš„æ„Ÿå—**
âŒ é—®é¢˜ï¼šå®¶äººè§‰å¾—Agent"å¤ªçƒ¦äºº"ï¼Œæ¯15åˆ†é’Ÿå‘æ¶ˆæ¯ã€‚  
âœ… è§£å†³ï¼šè®¾ç½®"å…æ‰“æ‰°æ—¶æ®µ"ï¼Œåªåœ¨å…³é”®æ—¶åˆ»é€šçŸ¥ã€‚ä½¿ç”¨Heartbeatçš„`HEARTBEAT_OK`æœºåˆ¶ã€‚

### 10.4.4 æ‰©å±•æ–¹å‘

**ä¸å…¶ä»–ç« èŠ‚çš„è”åŠ¨**ï¼š
- **ç¬¬8ç« ï¼ˆä¿¡æ¯èšåˆï¼‰**ï¼šMorning Briefingå¯ä»¥é›†æˆRedditæ‘˜è¦ã€YouTubeæ›´æ–°
- **ç¬¬9ç« ï¼ˆå†…å®¹ç”Ÿäº§ï¼‰**ï¼šTodoist Task Managerçš„æ¨ç†æ—¥å¿—å¯ä»¥ä½œä¸ºå†…å®¹åˆ›ä½œç´ æ
- **ç¬¬11ç« ï¼ˆDevOpsï¼‰**ï¼šAutonomous PMå¯ä»¥ç®¡ç†åŸºç¡€è®¾æ–½å˜æ›´é¡¹ç›®
- **ç¬¬12ç« ï¼ˆçŸ¥è¯†ç®¡ç†ï¼‰**ï¼šNewsletteræ‘˜è¦å­˜å…¥çŸ¥è¯†åº“ï¼Œå½¢æˆä¸ªäººç ”ç©¶ç³»ç»Ÿ

**å•†ä¸šåŒ–æ–¹å‘**ï¼š
- **ä¼ä¸šç‰ˆPM Agent**ï¼šæ¥å…¥Jiraã€GitHubã€Slackï¼Œæˆä¸ºå›¢é˜Ÿçš„è™šæ‹Ÿé¡¹ç›®ç»ç†
- **å®¶åº­åŠ©æ‰‹SaaS**ï¼šæ‰“åŒ…æˆè®¢é˜…æœåŠ¡ï¼Œ$9.99/æœˆï¼ŒæœåŠ¡10ä¸‡å®¶åº­
- **å®¢æœè‡ªåŠ¨åŒ–å¹³å°**ï¼šMulti-Channel Customer Serviceä½œä¸ºäº§å“ï¼Œå–ç»™å°ä¼ä¸š

### 10.4.5 å®è·µå»ºè®®

**ä»å“ªé‡Œå¼€å§‹ï¼Ÿ**
1. **ä¸ªäººç”¨æˆ·**ï¼šå…ˆåšMorning Briefingï¼Œç«‹ç«¿è§å½±
2. **å›¢é˜Ÿé¢†å¯¼**ï¼šè¯•è¯•Autonomous PMï¼Œç®¡ç†ä¸€ä¸ªå°é¡¹ç›®
3. **å®¶åº­ç”¨æˆ·**ï¼šä»æ—¥å†èšåˆå¼€å§‹ï¼Œè§£å†³æœ€ç—›çš„å†²çªé—®é¢˜

**å¦‚ä½•è¡¡é‡æˆåŠŸï¼Ÿ**
- **æ—¶é—´èŠ‚çœ**ï¼šæ¯å¤©èŠ‚çœå¤šå°‘åˆ†é’Ÿï¼Ÿï¼ˆä¾‹å¦‚ï¼šEmail TriageèŠ‚çœ30åˆ†é’Ÿï¼‰
- **å‡å°‘é—æ¼**ï¼šå¤šå°‘é‡è¦äº‹é¡¹ä¸å†è¢«é—å¿˜ï¼Ÿï¼ˆä¾‹å¦‚ï¼šå®¶åº­æ—¥å†å†²çªå‡å°‘80%ï¼‰
- **æå‡æ»¡æ„åº¦**ï¼šå›¢é˜Ÿæˆ–å®¶äººçš„åé¦ˆå¦‚ä½•ï¼Ÿ

**æŒç»­ä¼˜åŒ–**ï¼š
- **ç¬¬1å‘¨**ï¼šè§‚å¯ŸAgentçš„è¡Œä¸ºï¼Œè®°å½•é—®é¢˜
- **ç¬¬2å‘¨**ï¼šè°ƒæ•´å‚æ•°ï¼ˆè¿‡æ»¤é˜ˆå€¼ã€é€šçŸ¥é¢‘ç‡ï¼‰
- **ç¬¬1ä¸ªæœˆ**ï¼šè®©AIå­¦ä¹ ä½ çš„åå¥½ï¼Œä¸ªæ€§åŒ–å®šåˆ¶
- **ç¬¬3ä¸ªæœˆ**ï¼šè¯„ä¼°ROIï¼Œå†³å®šæ˜¯å¦æ‰©å±•æ›´å¤šåŠŸèƒ½

---

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼šç¬¬11ç« ã€ŠåŸºç¡€è®¾æ–½ä¸DevOpsè‡ªåŠ¨åŒ–ã€‹å°†æ·±å…¥Self-healing Serverçš„å®Œæ•´å®ç°â€”â€”ä»å¥åº·ç›‘æ§åˆ°è‡ªåŠ¨ä¿®å¤ï¼Œä»Kubernetesåˆ°Terraformï¼Œè®©Agentæˆä¸ºä½ çš„24/7 SREå·¥ç¨‹å¸ˆã€‚å¦‚æœä½ ç®¡ç†æœåŠ¡å™¨æˆ–äº‘èµ„æºï¼Œåƒä¸‡ä¸è¦é”™è¿‡ï¼

---

> ğŸ“š **ç« èŠ‚å›é¡¾**  
> - 10.1 ä¸ªäººç”Ÿäº§åŠ›ç³»ç»Ÿï¼šMorning Briefingã€Email Triageã€Multi-Channel Assistantã€Todoisté›†æˆ  
> - 10.2 å¤šäºº/å¤šé¡¹ç›®ç®¡ç†ï¼šAutonomous PMã€STATE.yamlå®æˆ˜ã€ä¾èµ–ç®¡ç†  
> - 10.3 å®¶åº­åä½œåŠ©æ‰‹ï¼šæ—¥å†èšåˆã€å†²çªæ£€æµ‹ã€åº“å­˜ç®¡ç†ã€Multi-Channelå®¢æœ  
>  
> **å…³é”®æ¦‚å¿µ**ï¼šä¸»åŠ¨èšåˆã€ç»Ÿä¸€å…¥å£ã€æ¸è¿›å¼è‡ªåŠ¨åŒ–ã€å¯è§‚æµ‹æ€§ã€STATE.yaml  
>  
> **ä»£ç ä»“åº“**ï¼šæœ¬ç« æ‰€æœ‰æ¡ˆä¾‹ä»£ç è§ `github.com/openclaw-book/chapter-10`

---

**å­—æ•°ç»Ÿè®¡**ï¼šçº¦9,200å­—ï¼ˆç¬¦åˆ9,000å­—ç›®æ ‡ï¼‰

**AIè¾…åŠ©æç¤ºæ¡†**ï¼šå…±5ä¸ªï¼ˆè¶…è¿‡è¦æ±‚çš„4ä¸ªï¼‰

**æ¡ˆä¾‹å®Œæ•´æ€§**ï¼š7ä¸ªå®Œæ•´æ¡ˆä¾‹ï¼ŒåŒ…å«æ¶æ„è®¾è®¡ã€ä»£ç å®ç°ã€é…ç½®æ–‡ä»¶ã€å®è·µå»ºè®®

**é£æ ¼**ï¼šä¸­æ–‡ï¼Œä¸“ä¸šä½†å‹å¥½ï¼ŒæŠ€æœ¯æ·±åº¦ä¸å¯è¯»æ€§å¹³è¡¡

---

## å‚è€ƒèµ„æ–™

æœ¬ç« å¼•ç”¨çš„æ¡ˆä¾‹å‡æ¥è‡ª [awesome-openclaw-usecases](https://github.com/hesamsheikh/awesome-openclaw-usecases) ç¤¾åŒºä»“åº“ï¼š

- [Custom Morning Brief](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/custom-morning-brief.md)
- [Inbox De-clutter](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/inbox-declutter.md)
- [Multi-Channel Assistant](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/multi-channel-assistant.md)
- [Todoist Task Manager](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/todoist-task-manager.md)
- [Autonomous Project Management](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/autonomous-project-management.md)
- [Multi-Channel Customer Service](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/multi-channel-customer-service.md)
