# 🛡️ 第7章：安全边界与风险管理

> *"给Agent权限就像给孩子钥匙——不是不能给，而是要想清楚后果。"*

当你第一次看到Agent自主执行任务时，兴奋之余可能会忽略一个关键问题：**它有权限做这些事吗？它应该有吗？**

本章将直面AI Agent系统中最容易被忽视但最不能忽视的问题：安全边界与风险管理。我们会从真实的灾难案例出发，逐步构建一套完整的安全防护体系。

---

## ⚠️ 7.1 真实的威胁：Day 1就能发生的灾难

### 7.1.1 案例：API Key泄露的48小时

这是一个真实的故事。

某创业公司搭建了一个简单的Reddit摘要Agent，部署在GitHub私有仓库。开发者在配置文件中硬编码了Reddit API Key，提交时没有注意。两天后，仓库因为团队变动转为公开——48小时内，API Key被扫描工具发现，Reddit账号被用于发送垃圾广告，最终账号被永久封禁。

**更糟糕的是**：这个Key同时也是公司社交媒体管理工具的认证凭证，导致整个营销自动化系统瘫痪。

这不是罕见事件。根据GitGuardian 2023年报告，GitHub上每天有超过10,000个新的secrets泄露。AI Agent系统因为涉及大量外部API集成，面临的风险更高。

> 💡 **AI辅助提示**
> 
> 不确定什么是API Key或为什么泄露会有危险？问ChatGPT：
> "什么是API Key？为什么不能公开？如果泄露会发生什么？"
> 
> AI会用通俗语言解释认证凭证的概念，以及常见的安全风险。

### 7.1.2 AI的"无意识"危险行为

AI Agent不会主动作恶，但它会**无意识地做出危险决策**。

**真实案例集**：

1. **硬编码凭证**  
   开发者让Agent"记住"数据库密码以便下次连接。Agent将其写入了AGENTS.md配置文件，该文件被提交到了公开的GitHub仓库。

2. **过度授权请求**  
   Email Triage Agent需要"读取邮件"权限，开发者在OAuth授权时顺手点了"完全访问"，包括删除、发送、修改所有邮件的权限。某次Agent误判，将200封重要邮件标记为垃圾邮件并归档。

3. **不可逆操作的批量执行**  
   Self-healing Server Agent检测到"磁盘占用过高"，分析日志后决定清理`/var/log/*`。不幸的是，某个关键服务的配置文件也在该目录下，清理后服务无法启动，且没有备份。

4. **权限提升请求**  
   某Agent需要修改Nginx配置文件（需要sudo），开发者临时用`sudo chmod 777`解决权限问题，忘记改回来。后续该Agent在调试时意外修改了系统文件。

这些案例的共同特点：
- **不是Agent的恶意行为**，而是设计时的安全缺陷
- **后果都是不可逆的**，且往往在凌晨或周末发生（Cron Job最活跃的时候）
- **都可以通过合理的架构设计避免**

> 🔧 **遇到错误？**
> 
> 如果你的Agent意外删除了文件或修改了配置，不要慌张：
> 1. 立即停止Agent（`openclaw gateway stop`）
> 2. 检查是否有Git版本控制或备份
> 3. 把情况描述给AI：  
>    "我的Agent误删了[文件/数据]，如何恢复？我的备份策略是[描述或'没有']"
> 
> AI可以帮你找到恢复方案（Git revert、系统快照、云备份等）。

### 7.1.3 过度授权的蝴蝶效应

最危险的不是Agent做了什么，而是**它能做但你以为它不会做的事**。

**权限分析表**：

| Agent用途 | 需要的最小权限 | 常见的过度授权 | 潜在风险 |
|----------|--------------|--------------|---------|
| Email Triage | 只读邮件、添加标签 | 完全访问Gmail API | 删除邮件、发送邮件、修改过滤器 |
| Reddit Digest | 读取指定subreddit | Reddit账号完全访问 | 发帖、私信、修改设置 |
| Self-healing Server | 重启指定服务、查看日志 | SSH root权限 | 删除文件、修改系统配置、安装软件 |
| GitHub PR Reviewer | 读取代码、评论PR | 仓库管理员权限 | 合并PR、删除分支、修改CI配置 |
| n8n Workflow Trigger | 调用指定Webhook | n8n全局Admin Token | 修改所有Workflow、访问所有凭证 |

**真实场景**：某公司的Customer Service Agent拥有"完全访问CRM系统"的权限（包括修改客户数据、删除记录、导出所有联系人）。某次Agent误判客户请求，批量修改了500个客户的地址信息。恢复数据花了3天，客户投诉导致公司损失$50,000。

**问题的根源**：开发者在快速原型时给了过高权限，"以后再收紧"——但"以后"从未到来。

---

## 🔐 7.2 凭证隔离模式：Agent不持有钥匙

### 7.2.1 核心思想：零信任架构

传统的Agent设计：

```
Agent (拥有API Key) → 直接调用外部API
```

问题：
- Agent的配置文件包含凭证
- 凭证容易泄露（日志、错误信息、Git提交）
- Agent被攻陷 = 凭证被盗

**凭证隔离模式（n8n Pattern）**：

```
Agent (无凭证) → Webhook → n8n (持有凭证) → 外部API
```

#### 可视化：凭证隔离架构

```mermaid
flowchart LR
    subgraph Agent环境
        A[Agent<br/>❌ 无凭证<br/>只有Webhook URL]
    end
    
    subgraph 隔离层_n8n
        W[Webhook<br/>Token验证]
        V[输入验证<br/>白名单检查]
        N[n8n Workflow<br/>🔐 持有加密凭证]
    end
    
    subgraph 外部服务
        D[Docker API<br/>容器管理]
        K[Kubernetes API<br/>集群操作]
        S[Slack API<br/>告警通知]
        C[Cloud API<br/>AWS/Azure]
    end
    
    A -->|HTTP POST<br/>action+参数| W
    W -->|验证Token| V
    V -->|验证通过| N
    
    N -.->|使用Docker凭证| D
    N -.->|使用K8s凭证| K
    N -.->|使用Slack凭证| S
    N -.->|使用云凭证| C
    
    N -->|结果/错误| A
    
    style A fill:#ffcccc,stroke:#333,stroke-width:2px
    style W fill:#fff3cd,stroke:#333,stroke-width:2px
    style V fill:#fff3cd,stroke:#333,stroke-width:2px
    style N fill:#d4edda,stroke:#333,stroke-width:3px
    style D fill:#e2e3e5,stroke:#333
    style K fill:#e2e3e5,stroke:#333
    style S fill:#e2e3e5,stroke:#333
    style C fill:#e2e3e5,stroke:#333
```

**架构优势**：
1. **Agent无法泄露凭证**：它根本没有
2. **集中管理**：所有凭证在n8n中统一存储和加密
3. **可观测**：n8n记录每次调用，可视化审计
4. **可锁定**：出问题时关闭Webhook，不需要修改Agent配置
5. **权限精确控制**：n8n Workflow可以做输入验证和输出过滤
6. **防御层级**：Token验证 → 输入白名单 → 操作执行

> 💡 **AI辅助提示**
> 
> 不了解Webhook或n8n是什么？问AI：
> "什么是Webhook？n8n是做什么的？为什么用它能提高安全性？"
> 
> AI会解释这些工具如何作为中间层隔离凭证。

### 7.2.2 架构实现：n8n Workflow Orchestration案例

**场景**：构建一个Self-healing Server Agent，需要：
- 重启Docker容器（需要Docker API访问）
- 发送Slack告警（需要Slack Bot Token）
- 查询Kubernetes Pod状态（需要kubeconfig）
- 执行Terraform plan（需要云服务商凭证）

**传统方案的风险**：
```yaml
# ❌ 危险：凭证硬编码在配置文件
DOCKER_HOST: tcp://server.example.com:2376
DOCKER_CERT_PATH: /path/to/certs
SLACK_BOT_TOKEN: 
KUBE_CONFIG: /path/to/kubeconfig
AWS_ACCESS_KEY_ID: AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY: <your-secret-access-key-here>
```

一旦这个文件被提交到Git或被Agent输出到日志，所有凭证都会泄露。

**n8n Pattern实现**：

#### Step 1: 在n8n中设置凭证

n8n提供加密的Credential存储：

1. **Docker API Credential**：配置证书路径（仅n8n服务器可访问）
2. **Slack Credential**：存储Bot Token
3. **Kubernetes Credential**：存储kubeconfig
4. **AWS Credential**：存储Access Key和Secret Key

这些凭证**永远不离开n8n服务器**，使用AES-256加密存储。

#### Step 2: 创建Webhook Workflow

在n8n中创建一个Workflow：

```
Webhook节点 → 验证输入 → 选择操作 → 执行 → 返回结果
```

**Workflow详细配置**：

```javascript
// Webhook节点配置
{
  "path": "agent-ops",
  "method": "POST",
  "authentication": "headerAuth",  // 简单的Token认证
  "responseMode": "responseNode"
}

// 输入验证节点（Code节点）
if (!['restart_container', 'check_pods', 'send_alert'].includes($json.action)) {
  return { error: "Invalid action" };
}
if ($json.action === 'restart_container' && !$json.container_name) {
  return { error: "Missing container_name" };
}
// 更多验证逻辑...

// Switch节点：根据action选择分支

// 分支1: restart_container
Docker Node:
  - Credential: "Docker Production"
  - Operation: Restart Container
  - Container Name: {{ $json.container_name }}

// 分支2: check_pods  
Kubernetes Node:
  - Credential: "K8s Production Cluster"
  - Operation: List Pods
  - Namespace: {{ $json.namespace || 'default' }}

// 分支3: send_alert
Slack Node:
  - Credential: "Slack Bot Production"
  - Operation: Send Message
  - Channel: #ops-alerts
  - Message: {{ $json.message }}
```

#### Step 3: Agent调用Webhook（无凭证）

在Agent的TOOLS.md中只记录Webhook地址和简单Token：

```markdown
### Self-healing Operations

- n8n Webhook: https://n8n.example.com/webhook/agent-ops
- Auth Token: (stored in environment variable N8N_AGENT_TOKEN)
```

Agent代码示例：

```python
import os
import requests

N8N_WEBHOOK = "https://n8n.example.com/webhook/agent-ops"
AUTH_TOKEN = os.environ.get("N8N_AGENT_TOKEN")  # 从环境变量读取

def restart_container(container_name):
    response = requests.post(
        N8N_WEBHOOK,
        headers={"Authorization": f"Bearer {AUTH_TOKEN}"},
        json={
            "action": "restart_container",
            "container_name": container_name
        }
    )
    return response.json()

def check_k8s_pods(namespace="default"):
    response = requests.post(
        N8N_WEBHOOK,
        headers={"Authorization": f"Bearer {AUTH_TOKEN}"},
        json={
            "action": "check_pods",
            "namespace": namespace
        }
    )
    return response.json()
```

**关键点**：
- Agent的代码中**没有Docker/K8s/Slack凭证**
- 只有一个简单的Webhook Token（可以随时重置）
- 即使Agent代码泄露，攻击者也无法直接访问基础设施

### 7.2.3 可观测性与可控性

n8n Pattern的额外优势：**完整的审计日志**。

每次Agent调用Webhook，n8n都会记录：
- 时间戳
- 输入参数
- 执行结果
- 执行时长
- 错误信息（如果有）

**n8n Dashboard示例**：

```
[2024-02-15 03:24:18] ✅ restart_container
  Input: {"container_name": "nginx-proxy"}
  Output: {"status": "restarted", "uptime": "2s"}
  Duration: 1.2s

[2024-02-15 03:24:25] ❌ check_pods
  Input: {"namespace": "production"}
  Error: "Unauthorized: token expired"
  Duration: 0.3s

[2024-02-15 03:30:00] ✅ send_alert
  Input: {"message": "Disk usage >80% on server-03"}
  Output: {"ok": true, "message_id": "1234567890.123456"}
  Duration: 0.8s
```

**出现异常时的应对**：

1. **Agent行为异常**（频繁重启容器）  
   → 在n8n中暂停Webhook或添加Rate Limit

2. **凭证泄露**（怀疑Slack Token被盗）  
   → 在n8n中更新Slack Credential，Agent代码无需修改

3. **权限收紧**（不再允许Agent删除Pod）  
   → 在n8n Workflow中移除该操作分支，Agent调用会返回"Forbidden"

> 📚 **深入学习**
> 
> 想了解更多零信任架构和凭证管理最佳实践？问AI：
> "什么是零信任安全架构（Zero Trust）？如何在微服务系统中实现？给我3个实际案例。"
> 
> AI会介绍Google BeyondCorp、AWS IAM Roles等业界方案。

### 7.2.4 实战步骤：将现有Agent迁移到凭证隔离模式

**场景**：你有一个Email Triage Agent，当前直接使用Gmail API（在配置文件中存储OAuth Token）。

**迁移步骤**：

1. **安装n8n**（如果还没有）

```bash
# Docker部署（最简单）
docker run -d \
  --name n8n \
  -p 5678:5678 \
  -v ~/.n8n:/home/node/.n8n \
  n8nio/n8n

# 访问 http://localhost:5678 完成初始化
```

2. **在n8n中配置Gmail Credential**

- 打开n8n → Credentials → Add Credential → Gmail OAuth2
- 按提示完成OAuth授权（浏览器跳转到Google授权页面）
- n8n会存储并加密Access Token和Refresh Token

3. **创建Email Triage Workflow**

节点配置：
```
Webhook (接收Agent请求)
  ↓
Gmail Node (List Messages)
  - Credential: Gmail OAuth2
  - Max Results: 50
  - Label IDs: INBOX
  ↓
Function Node (返回简化数据)
  - 只返回 [id, subject, from, snippet]
  - 不返回完整邮件内容（避免数据泄露）
  ↓
Response Node (返回给Agent)
```

4. **修改Agent代码**

替换：
```python
# ❌ 旧代码：直接调用Gmail API
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build

creds = Credentials.from_authorized_user_file('token.json')
service = build('gmail', 'v1', credentials=creds)
results = service.users().messages().list(userId='me').execute()
```

为：
```python
# ✅ 新代码：调用n8n Webhook
import requests
import os

N8N_WEBHOOK = "https://n8n.example.com/webhook/email-triage"
AUTH_TOKEN = os.environ.get("N8N_EMAIL_TOKEN")

response = requests.post(
    N8N_WEBHOOK,
    headers={"Authorization": f"Bearer {AUTH_TOKEN}"},
    json={"action": "list_inbox"}
)
emails = response.json()
```

5. **删除本地凭证文件**

```bash
rm token.json credentials.json  # 这些文件不再需要
echo "N8N_EMAIL_TOKEN=your-webhook-token" >> .env  # 只需要Webhook Token
```

6. **验证安全性提升**

测试场景：
- Agent日志中不再出现OAuth Token
- 即使Agent配置被泄露，攻击者也无法访问Gmail
- 可以在n8n Dashboard中看到所有邮件访问记录

**迁移后的架构对比**：

| 维度 | 迁移前 | 迁移后 |
|-----|--------|--------|
| 凭证存储 | Agent配置文件（明文或加密） | n8n加密存储 |
| 泄露风险 | 高（配置文件、日志、错误信息） | 低（Agent无凭证） |
| 可观测性 | 无（Agent日志混乱） | 高（n8n Dashboard） |
| 应急响应 | 需要修改Agent配置并重启 | 只需修改n8n Workflow |
| 权限控制 | 难（OAuth scope在授权时决定） | 易（n8n Workflow过滤） |

> 🔧 **遇到错误？**
> 
> n8n Workflow调试时遇到问题？
> 1. 点击n8n中的"Execute Workflow"测试单个节点
> 2. 查看每个节点的输入/输出数据
> 3. 把错误信息给AI：  
>    "我在n8n中配置Gmail节点时遇到错误：[粘贴错误]，如何解决？"
> 
> AI可以帮你诊断配置问题（常见：OAuth scope不足、Webhook认证失败）。

---

## 🛡️ 7.3 防护栏设计：主动防御而非被动修复

凭证隔离解决了"Agent拿不到钥匙"的问题，但还有两个关键问题：
1. **如何防止开发者不小心提交凭证？**（人为错误）
2. **如何限制Agent的危险行为？**（过度授权）

答案是：**多层防护栏（Guardrails）**。

#### 可视化：多层防护栏架构

```mermaid
flowchart TD
    DEV[开发者修改代码<br/>可能包含敏感信息] --> L1{防护层1<br/>Pre-commit Hook}
    
    L1 -->|发现secrets| BLOCK1[❌ 提交被拦截<br/>显示泄露位置]
    L1 -->|通过检查| L2{防护层2<br/>分支保护}
    
    BLOCK1 --> DEV
    
    L2 -->|需要PR审查| L3[人工代码审查<br/>必须至少1人批准]
    L3 -->|发现问题| BLOCK2[❌ PR被拒绝<br/>要求修改]
    L3 -->|审查通过| L4{防护层3<br/>CI检查}
    
    BLOCK2 --> DEV
    
    L4 -->|运行自动测试| CHECK[TruffleHog扫描<br/>安全审计<br/>代码质量检查]
    CHECK -->|失败| BLOCK3[❌ CI失败<br/>阻止合并]
    CHECK -->|通过| L5[✅ 合并到主分支]
    
    BLOCK3 --> DEV
    
    L5 --> L6{防护层4<br/>运行时监控}
    L6 --> AUDIT[审计日志记录<br/>异常行为检测]
    AUDIT --> ALERT{发现异常?}
    ALERT -->|是| RESPOND[🚨 告警<br/>自动响应<br/>人工介入]
    ALERT -->|否| PROD[✅ 生产环境<br/>持续运行]
    
    RESPOND --> INVESTIGATE[调查根因<br/>修复漏洞]
    INVESTIGATE --> DEV
    
    style L1 fill:#ffcccc,stroke:#333,stroke-width:2px
    style L2 fill:#fff3cd,stroke:#333,stroke-width:2px
    style L4 fill:#d4edda,stroke:#333,stroke-width:2px
    style L6 fill:#d1ecf1,stroke:#333,stroke-width:2px
    style BLOCK1 fill:#f8d7da,stroke:#333
    style BLOCK2 fill:#f8d7da,stroke:#333
    style BLOCK3 fill:#f8d7da,stroke:#333
    style RESPOND fill:#f8d7da,stroke:#333,stroke-width:2px
```

**四层防御体系**：
1. **🔴 Pre-commit（本地）**：开发阶段拦截，最早发现问题
2. **🟡 分支保护（Git平台）**：人工审查，防止绕过本地检查
3. **🟢 CI自动化（云端）**：全面扫描，多工具验证
4. **🔵 运行时监控（生产）**：持续审计，快速响应

**关键原则**：
- **纵深防御**：单层防御不够，多层叠加
- **快速反馈**：越早发现问题，修复成本越低
- **自动化优先**：减少人为疏忽
- **持续审计**：不是一次性设置，而是持续监控

### 7.3.1 Pre-commit Hooks：在提交前拦截

**场景**：开发者在AGENTS.md中临时写入了测试用的API Key，忘记删除就准备提交。

**防护栏1：TruffleHog扫描**

TruffleHog是一个开源工具，可以扫描Git提交中的secrets（API Key、密码、Token等）。

**安装与配置**：

```bash
# 安装TruffleHog
pip install truffleHog

# 或使用Go版本（更快）
brew install truffleHog
```

**设置Pre-commit Hook**：

在你的Git仓库中创建`.git/hooks/pre-commit`文件：

```bash
#!/bin/bash

echo "🔍 Scanning for secrets with TruffleHog..."

# 扫描暂存的文件
git diff --cached --name-only | while read file; do
  if [ -f "$file" ]; then
    truffleHog filesystem "$file" --json --only-verified
  fi
done > /tmp/truffleHog-results.json

# 检查是否发现secrets
if [ -s /tmp/truffleHog-results.json ]; then
  echo "❌ Secrets detected! Commit aborted."
  echo "Details:"
  cat /tmp/truffleHog-results.json | jq -r '.[] | "  - \(.File): \(.Match)"'
  echo ""
  echo "Please remove secrets and try again."
  exit 1
fi

echo "✅ No secrets detected. Proceeding with commit."
exit 0
```

```bash
chmod +x .git/hooks/pre-commit
```

**测试效果**：

```bash
# 尝试提交包含API Key的文件
echo "SLACK_BOT_TOKEN=" >> AGENTS.md
git add AGENTS.md
git commit -m "Update config"

# 输出：
# 🔍 Scanning for secrets with TruffleHog...
# ❌ Secrets detected! Commit aborted.
# Details:
#   - AGENTS.md:  (Slack Bot Token)
# Please remove secrets and try again.
```

**高级配置**：使用`.truffleHog.yaml`自定义规则

```yaml
# 忽略误报
excludePaths:
  - "docs/examples/**"  # 文档中的示例代码
  - "*.test.js"         # 测试文件

# 自定义检测规则
rules:
  - id: custom-api-key
    pattern: 'API_KEY=[A-Za-z0-9]{32}'
    description: "Custom API Key Format"
```

> 💡 **AI辅助提示**
> 
> 不熟悉Git Hooks或Shell脚本？问AI：
> "什么是Git Pre-commit Hook？如何在[Mac/Windows/Linux]上设置？给我一个完整示例。"
> 
> AI会解释Hooks机制，并给出适合你系统的配置方法。

### 7.3.2 分支保护：代码审查强制化

即使Pre-commit Hook拦截了本地提交，开发者仍可能：
- 禁用Hook（`git commit --no-verify`）
- 直接在服务器上修改代码
- 通过Web界面编辑文件

**防护栏2：Git平台的分支保护**

以GitHub为例（Gitea、GitLab类似）：

**分支保护规则设置**：

1. **Repository Settings → Branches → Add rule**
2. **Branch name pattern**: `main` 或 `production`
3. **勾选以下选项**：
   - ✅ **Require pull request reviews before merging**（至少1人审查）
   - ✅ **Dismiss stale pull request approvals when new commits are pushed**
   - ✅ **Require status checks to pass before merging**
     - 添加CI检查：`truffleHog-scan`、`security-audit`
   - ✅ **Require branches to be up to date before merging**
   - ✅ **Include administrators**（管理员也必须走PR流程）

**Self-healing Server案例的配置**：

该Agent运行在生产服务器上，拥有重启服务、修改配置的权限。如何防止Agent代码被恶意修改？

**Gitea + 分支保护实践**：

1. **搭建私有Gitea实例**（如果还没有）

```bash
docker run -d \
  --name gitea \
  -p 3000:3000 \
  -v /var/lib/gitea:/data \
  gitea/gitea:latest
```

2. **创建Self-healing Agent仓库**

```bash
cd ~/self-healing-agent
git init
git remote add origin https://gitea.example.com/ops/self-healing-agent.git
```

3. **在Gitea中配置分支保护**

- Settings → Repository → Protected Branches
- 保护`main`分支：
  - ✅ 禁止强制推送
  - ✅ 禁止删除分支
  - ✅ 要求至少1个审查者批准PR
  - ✅ 要求状态检查通过（CI/CD pipeline）

4. **配置CI Pipeline检查**（Gitea Actions）

`.gitea/workflows/security-check.yml`：

```yaml
name: Security Check

on:
  pull_request:
    branches: [main]

jobs:
  scan-secrets:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run TruffleHog
        run: |
          docker run --rm -v "$PWD:/scan" \
            trufflesecurity/trufflehog:latest \
            filesystem /scan --json --fail
      
      - name: Scan for suspicious patterns
        run: |
          # 检查是否有危险的Shell命令
          if grep -r "rm -rf /" .; then
            echo "❌ Dangerous command detected!"
            exit 1
          fi
          
          # 检查是否有硬编码的IP/域名（应该用配置文件）
          if grep -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" *.py; then
            echo "⚠️ Hardcoded IP detected. Use config instead."
            exit 1
          fi
```

5. **开发流程示例**

```bash
# 开发者工作流程
git checkout -b fix-disk-cleanup
# 修改代码...
git add .
git commit -m "Improve disk cleanup logic"
git push origin fix-disk-cleanup

# 在Gitea中创建PR
# → CI自动运行Security Check
# → 至少1人审查代码
# → 所有检查通过后才能合并到main
```

**关键点**：
- **Agent部署脚本只从`main`分支拉取代码**
- 任何修改都必须经过审查和CI检查
- 即使是管理员也无法绕过（Include administrators选项）

### 7.3.3 定期审计：发现潜在问题

防护栏不是一次性设置，而是**持续的审计和改进**。

**Self-healing Server的完整安全审计清单**：

#### 每日自动检查（Cron Job）

```bash
# /etc/cron.daily/agent-security-audit
#!/bin/bash

REPORT="/var/log/agent-security-$(date +%Y%m%d).log"

echo "=== Agent Security Audit Report ===" > $REPORT
echo "Date: $(date)" >> $REPORT
echo "" >> $REPORT

# 1. 检查Git仓库是否有未审查的commit
echo "## Git Commit Audit" >> $REPORT
cd /opt/self-healing-agent
git log --since="24 hours ago" --pretty=format:"%h - %an: %s" >> $REPORT
echo "" >> $REPORT

# 2. 检查Agent的权限
echo "## Permission Audit" >> $REPORT
echo "Agent user: $(whoami)" >> $REPORT
echo "Sudo permissions:" >> $REPORT
sudo -l -U agent-user >> $REPORT
echo "" >> $REPORT

# 3. 检查最近的API调用日志
echo "## Recent API Calls" >> $REPORT
grep "n8n webhook" /var/log/agent.log | tail -20 >> $REPORT
echo "" >> $REPORT

# 4. 检查是否有新的环境变量（可能包含凭证）
echo "## Environment Variables" >> $REPORT
env | grep -i "token\|key\|secret\|password" >> $REPORT || echo "None found" >> $REPORT
echo "" >> $REPORT

# 5. 检查配置文件是否被修改
echo "## Configuration Changes" >> $REPORT
find /opt/self-healing-agent -name "*.md" -o -name "*.yaml" -mtime -1 >> $REPORT
echo "" >> $REPORT

# 6. 检查是否有失败的操作（可能是攻击尝试）
echo "## Failed Operations" >> $REPORT
grep "ERROR\|FAILED" /var/log/agent.log | tail -10 >> $REPORT
echo "" >> $REPORT

# 发送报告到Slack（通过n8n）
curl -X POST https://n8n.example.com/webhook/security-report \
  -H "Authorization: Bearer $N8N_AUDIT_TOKEN" \
  -F "report=@$REPORT"
```

#### 每周人工审查（Checklist）

```markdown
# Weekly Security Review Checklist

## 权限审查
- [ ] Agent用户的sudo权限是否最小化？
- [ ] SSH密钥是否仍然有效且安全？
- [ ] n8n Webhook Token是否需要轮换？

## 代码审查
- [ ] 查看上周所有合并到main的PR
- [ ] 检查是否有绕过审查的直接commit（应该为0）
- [ ] 运行`git log --all --grep="TODO\|FIXME\|HACK"`查找技术债务

## 日志分析
- [ ] 是否有异常的API调用频率？（DDoS、误操作）
- [ ] 是否有新的错误类型？（可能是漏洞）
- [ ] n8n Dashboard中是否有失败率上升？

## 凭证管理
- [ ] n8n中所有Credential是否仍然有效？
- [ ] 是否有即将过期的证书/Token？
- [ ] 是否有不再使用的Credential可以删除？

## 备份验证
- [ ] 测试从备份恢复Agent配置（至少每月一次）
- [ ] 验证Git历史完整性
- [ ] 检查日志归档是否正常
```

> 📚 **深入学习**
> 
> 想了解企业级的安全审计实践？问AI：
> "什么是SOC2审计？DevSecOps流程中如何集成安全检查？给我一个完整的CI/CD安全Pipeline示例。"
> 
> AI会介绍Snyk、Aqua Security、HashiCorp Vault等工业级工具。

### 7.3.4 应急响应：当安全事件发生时

再完美的防护栏也可能被突破。关键是**快速响应**。

**安全事件应急手册**：

#### 场景1：怀疑API Key泄露

**症状**：
- 收到云服务商的"异常API调用"告警
- n8n Dashboard显示来自未知IP的Webhook请求
- Agent行为异常（频繁调用某个API）

**应急步骤**：

```bash
# 1. 立即停止Agent（5秒内完成）
openclaw gateway stop
# 或
systemctl stop openclaw-agent

# 2. 锁定n8n Webhook（防止进一步滥用）
# 登录n8n → 找到相关Workflow → Deactivate

# 3. 轮换所有可能泄露的凭证
# - 在n8n中更新Credential（重新授权OAuth、生成新Token）
# - 更新Agent的Webhook Token
# - 撤销云服务商的Access Key

# 4. 审计日志（找到泄露源头）
grep "API_KEY\|TOKEN" /var/log/agent.log
git log -p --all -S ""  # 搜索Git历史中的Slack Token

# 5. 修复漏洞（根据审计结果）
# - 如果是代码泄露：删除敏感commit、强制推送
# - 如果是配置错误：更新.gitignore、加强Pre-commit Hook
# - 如果是第三方漏洞：更新依赖、打补丁

# 6. 恢复服务（确认安全后）
# - 验证新凭证有效
# - 小范围测试Agent行为
# - 逐步恢复到生产
openclaw gateway start
```

**Post-mortem分析**（事后总结）：

```markdown
# Security Incident Report: API Key Leak (2024-02-15)

## Timeline
- 03:24 AM: 云服务商告警"异常API调用"
- 03:26 AM: 停止Agent、锁定Webhook
- 03:35 AM: 完成凭证轮换
- 04:10 AM: 完成日志审计，发现根因
- 04:30 AM: 修复漏洞，恢复服务

## Root Cause
开发者在调试时临时将AWS Key写入环境变量，重启服务器后环境变量被写入系统日志，日志被自动上传到公开的日志分析平台。

## Immediate Fix
- 删除日志平台上的敏感日志
- 更新AWS Access Key
- 配置日志脱敏规则（自动替换Key/Token）

## Long-term Prevention
- [ ] 在Pre-commit Hook中检测环境变量设置
- [ ] 配置Systemd服务的日志脱敏
- [ ] 添加CI检查：禁止在代码中使用`export`设置敏感变量
- [ ] 培训：所有开发者必须使用`.env`文件（已加入.gitignore）

## Cost Impact
- 攻击者消耗$23 AWS费用（已通过支持票务追回）
- 人力成本：3小时 × 2人 = 6工时

## Lessons Learned
1. ✅ n8n隔离模式有效：Agent本身没有泄露凭证
2. ✅ 应急响应流程有效：5分钟内完成隔离
3. ❌ 日志脱敏不足：需要加强
4. ❌ 开发者培训不足：需要定期安全培训
```

#### 场景2：Agent行为失控

**症状**：
- Agent频繁重启服务（每分钟多次）
- 收到大量告警通知
- 服务器负载异常

**应急步骤**：

```bash
# 1. 立即停止Agent
openclaw gateway stop

# 2. 检查最近的决策日志
tail -100 /var/log/agent.log | grep "DECISION\|ACTION"

# 示例输出：
# [03:24:18] DECISION: Disk usage 85%, cleanup needed
# [03:24:19] ACTION: rm -rf /var/log/old/*
# [03:24:20] DECISION: Service nginx down, restart needed
# [03:24:21] ACTION: systemctl restart nginx
# [03:24:22] DECISION: Service nginx down, restart needed  # ← 循环了！
# [03:24:23] ACTION: systemctl restart nginx

# 3. 识别问题：Nginx启动失败但Agent没有诊断出根因

# 4. 人工修复根因
sudo nginx -t  # 测试配置
# nginx: [emerg] unknown directive "upstrean" in /etc/nginx/nginx.conf:45
# → 配置文件有typo

sudo vim /etc/nginx/nginx.conf  # 修复typo
sudo systemctl start nginx

# 5. 更新Agent逻辑（防止未来再次发生）
# 在Agent的AGENTS.md中添加：
# "如果服务连续3次重启失败，停止自动重启，发送告警给人工处理"

# 6. 恢复Agent
openclaw gateway start
```

---

## 📋 7.4 风险评估框架：决策前的思考清单

每次给Agent新权限或新任务时，问自己这5个问题。

### 7.4.1 五问清单（Five Questions Framework）

#### 问题1：最坏情况会发生什么？

**示例**：

| Agent任务 | 最坏情况 | 后果严重性 |
|----------|---------|-----------|
| Email Triage（只读） | 泄露邮件内容 | 中等（隐私泄露） |
| Email Triage（完全访问） | 删除所有邮件 | 严重（业务中断） |
| Self-healing（重启服务） | 频繁重启导致服务不可用 | 严重（业务中断） |
| Self-healing（rm命令） | 误删关键文件 | 灾难性（数据丢失） |
| GitHub PR Review（评论） | 发表不当言论 | 中等（声誉受损） |
| GitHub PR Review（合并） | 合并恶意代码到生产 | 灾难性（安全漏洞） |

**决策规则**：
- **灾难性后果** → 必须有人工审核，或完全禁止
- **严重后果** → 需要可逆机制（备份、回滚）
- **中等后果** → 加强日志和监控
- **轻微后果** → 可以自动化

#### 问题2：Agent有权限做这个吗？应该有吗？

**权限评估表**：

```markdown
# 任务：Self-healing Server重启Docker容器

## 当前权限
- Agent运行用户：`agent-user`
- 当前sudo权限：`ALL=(ALL) NOPASSWD: ALL`  # ← 危险！

## 最小权限设计
Agent只需要：
- 重启特定的Docker容器（nginx, redis, postgres）
- 查看Docker容器状态
- 查看系统日志（只读）

## 修改sudo配置（/etc/sudoers）
```bash
# 移除原来的过度授权
# agent-user ALL=(ALL) NOPASSWD: ALL  # ← 删除

# 添加精确的权限
agent-user ALL=(ALL) NOPASSWD: /usr/bin/docker restart nginx
agent-user ALL=(ALL) NOPASSWD: /usr/bin/docker restart redis
agent-user ALL=(ALL) NOPASSWD: /usr/bin/docker restart postgres
agent-user ALL=(ALL) NOPASSWD: /usr/bin/docker ps
agent-user ALL=(ALL) NOPASSWD: /usr/bin/journalctl -u docker*
```

**验证**：
```bash
# 测试Agent只能执行允许的命令
sudo -u agent-user docker restart nginx   # ✅ 成功
sudo -u agent-user docker restart mysql   # ❌ 失败（未授权）
sudo -u agent-user rm /etc/nginx/nginx.conf  # ❌ 失败（未授权）
```

#### 问题3：出错了能撤销吗？

**可逆性设计**：

| 操作类型 | 可逆性 | 实现方法 |
|---------|--------|---------|
| 修改配置文件 | ✅ 可逆 | Git版本控制 + 自动备份 |
| 重启服务 | ✅ 可逆 | 可以再次重启 |
| 删除文件 | ⚠️ 部分可逆 | `trash`命令 + 定期备份 |
| 发送邮件/消息 | ❌ 不可逆 | 添加"确认"步骤 |
| 转账/付款 | ❌ 不可逆 | 必须人工审批 |
| 删除数据库记录 | ⚠️ 部分可逆 | Soft delete + 定期快照 |

**实战示例：文件删除的可逆设计**

```bash
# ❌ 危险：直接删除
rm -rf /var/log/old/*

# ✅ 安全：先移动到trash目录
mkdir -p /opt/agent-trash
mv /var/log/old/* /opt/agent-trash/$(date +%Y%m%d)/

# 定时清理trash（Cron Job，保留7天）
0 3 * * * find /opt/agent-trash -type d -mtime +7 -exec rm -rf {} \;
```

#### 问题4：谁能审计Agent的行为？

**可观测性设计**：

1. **结构化日志**

```python
import logging
import json
from datetime import datetime

logger = logging.getLogger("agent")

def log_action(action, params, result, duration):
    log_entry = {
        "timestamp": datetime.utcnow().isoformat(),
        "action": action,
        "params": params,
        "result": result,
        "duration_ms": duration,
        "agent_version": "v1.2.3"
    }
    logger.info(json.dumps(log_entry))

# 使用示例
start = time.time()
result = restart_container("nginx")
duration = (time.time() - start) * 1000
log_action("restart_container", {"name": "nginx"}, result, duration)
```

输出日志：
```json
{"timestamp": "2024-02-15T03:24:18.123Z", "action": "restart_container", "params": {"name": "nginx"}, "result": "success", "duration_ms": 1234, "agent_version": "v1.2.3"}
```

2. **审计Dashboard**

使用Grafana + Loki查询日志：

```promql
# 查询过去24小时所有失败的操作
{job="agent"} |= "result" | json | result="failed"

# 查询特定Agent的所有操作
{job="agent", agent_version="v1.2.3"} | json

# 查询异常频繁的操作（每分钟超过10次）
rate({job="agent"} |= "action" | json [1m]) > 10
```

3. **人工审查触发器**

```python
# 在关键操作前发送确认请求（Slack）
def require_approval(action, params, timeout=300):
    """
    发送Slack消息，等待人工批准
    timeout: 超时时间（秒），默认5分钟
    """
    message = f"🤖 Agent请求批准操作：\n操作：{action}\n参数：{json.dumps(params, indent=2)}\n\n回复 `approve` 批准，或 `deny` 拒绝。"
    
    # 通过n8n发送Slack消息
    response = requests.post(
        N8N_WEBHOOK,
        json={"action": "send_slack_approval", "message": message}
    )
    approval_id = response.json()["approval_id"]
    
    # 等待人工响应
    for _ in range(timeout):
        status = check_approval_status(approval_id)
        if status == "approved":
            return True
        elif status == "denied":
            return False
        time.sleep(1)
    
    # 超时 = 拒绝
    return False

# 在删除数据前要求批准
if require_approval("delete_old_logs", {"path": "/var/log/old/*"}):
    delete_logs("/var/log/old/*")
else:
    logger.warning("Operation denied by human operator")
```

#### 问题5：凭证存在哪里？如何保护？

**凭证存储矩阵**：

| 存储位置 | 安全性 | 适用场景 | 注意事项 |
|---------|-------|---------|---------|
| 代码中硬编码 | ❌ 极低 | **永远不要这样做** | 必定泄露 |
| 配置文件明文 | ❌ 低 | 本地开发（临时） | 不能提交到Git |
| 环境变量 | ⚠️ 中等 | 简单部署 | 日志可能泄露 |
| `.env`文件 | ⚠️ 中等 | 本地开发 | 必须在.gitignore中 |
| 加密的配置文件 | ✅ 较高 | 生产环境 | 需要管理加密密钥 |
| n8n Credential Store | ✅ 高 | 推荐方案 | 凭证永不离开n8n |
| HashiCorp Vault | ✅ 极高 | 企业级部署 | 复杂度较高 |

**推荐：三层凭证架构**

```
Layer 1 (Agent)
  - 只存储n8n Webhook URL和简单Token
  - 通过环境变量传递（N8N_AGENT_TOKEN）

Layer 2 (n8n)
  - 存储外部服务的凭证（加密）
  - Credentials: Gmail OAuth, AWS Key, Slack Token

Layer 3 (外部服务)
  - 使用最小权限原则
  - OAuth scope限制、IAM Role限制
```

### 7.4.2 决策矩阵：自动化层次选择

根据风险等级选择合适的自动化层次：

| 风险等级 | 可逆性 | 后果 | 推荐自动化层次 | 防护措施 |
|---------|-------|------|--------------|---------|
| 极低 | ✅ 完全可逆 | 无影响 | **L4-L5**（完全自动化） | 只需日志 |
| 低 | ✅ 可逆 | 轻微不便 | **L3-L4**（自动化+通知） | 日志 + 告警 |
| 中 | ⚠️ 部分可逆 | 业务影响 | **L2-L3**（建议+确认） | 备份 + 审计 |
| 高 | ❌ 不可逆 | 数据丢失 | **L1-L2**（仅建议） | 人工审批 |
| 极高 | ❌ 不可逆 | 灾难性后果 | **L0**（禁止自动化） | 完全人工 |

**实战示例：Email Triage的自动化层次决策**

| 操作 | 风险等级 | 可逆性 | 选择的层次 | 实现 |
|-----|---------|-------|-----------|------|
| 读取邮件 | 极低 | N/A | L4 | 自动执行，记录日志 |
| 标记标签 | 低 | ✅ 可逆 | L3 | 自动执行，每日总结 |
| 归档邮件 | 中 | ✅ 可逆 | L3 | 自动执行，可手动恢复 |
| 删除邮件 | 高 | ⚠️ 可恢复（30天） | L2 | 建议删除，人工确认 |
| 发送邮件 | 高 | ❌ 不可逆 | L1 | 草稿模式，人工发送 |

**配置示例（AGENTS.md）**：

```markdown
# Email Triage Agent 安全配置

## 自动化规则
- **自动执行**（L3-L4）：
  - 读取未读邮件
  - 标记标签（工作/个人/Newsletter/垃圾）
  - 归档已处理邮件

- **建议+确认**（L2）：
  - 删除垃圾邮件（每日汇总，批量确认）

- **禁止自动化**（L0）：
  - 发送邮件
  - 转发邮件
  - 修改邮件规则

## 应急停止
如果发现误判：
1. 发送消息 `/stop email-triage`
2. Agent会立即暂停所有操作
3. 查看 `/var/log/email-triage.log` 了解已执行的操作
4. 如需撤销，运行 `restore-last-batch.sh`
```

### 7.4.3 实战练习：评估你的Agent

选择一个你正在使用或计划部署的Agent，用五问清单评估：

**示例：Self-healing Server Agent**

```markdown
# Agent风险评估报告

## 基本信息
- Agent名称：Self-healing Server
- 用途：监控服务健康，自动重启失败的服务
- 部署环境：生产服务器（Ubuntu 22.04）

## 五问清单

### 1. 最坏情况会发生什么？
- **场景A**：Agent误判，频繁重启正常服务 → 业务中断
- **场景B**：Agent执行`rm`命令误删关键文件 → 数据丢失
- **场景C**：Agent的逻辑bug导致死循环 → 服务器资源耗尽

**严重性评级**：高（业务中断）到灾难性（数据丢失）

### 2. Agent有权限做这个吗？应该有吗？
**当前权限**：
- SSH root访问
- sudo无密码
- Docker API完全访问

**问题**：权限过高！

**改进方案**：
- 使用非root用户`agent-user`
- 限制sudo权限到特定命令（见7.4.1）
- 通过n8n Webhook隔离凭证

### 3. 出错了能撤销吗？
**当前状态**：
- ✅ 重启服务：可逆
- ❌ 删除日志：不可逆（无备份）
- ⚠️ 修改配置：部分可逆（依赖Git）

**改进方案**：
- 所有文件操作先备份
- 配置文件用Git版本控制
- 删除操作改用`trash`

### 4. 谁能审计Agent的行为？
**当前状态**：
- 日志存在`/var/log/agent.log`（无结构化）
- 无Dashboard
- 无告警机制

**改进方案**：
- 实现结构化JSON日志
- 集成Grafana + Loki
- 关键操作发送Slack通知

### 5. 凭证存在哪里？
**当前状态**：
- SSH密钥在`~/.ssh/id_rsa`（明文）
- Docker API通过环境变量`DOCKER_HOST`
- Slack Token在配置文件中

**改进方案**：
- 迁移到n8n凭证隔离模式
- 使用SSH Agent而非密钥文件
- 轮换Slack Token并加密存储

## 决策矩阵

| 操作 | 风险 | 自动化层次 | 当前实现 | 改进计划 |
|-----|-----|-----------|---------|---------|
| 监控服务状态 | 极低 | L4 | ✅ 已实现 | 无需改进 |
| 重启失败服务 | 中 | L3 | ✅ 已实现 | 添加频率限制 |
| 清理磁盘空间 | 高 | L2 | ❌ 当前L4 | **降级到L2，需人工确认** |
| 修改配置文件 | 高 | L2 | ❌ 当前L3 | **添加PR审查流程** |
| 执行系统更新 | 极高 | L0 | ✅ 禁止 | 保持禁止 |

## 行动计划

### 高优先级（本周完成）
- [ ] 限制sudo权限
- [ ] 实现n8n凭证隔离
- [ ] 将文件删除改为`trash`模式

### 中优先级（下周完成）
- [ ] 配置TruffleHog Pre-commit Hook
- [ ] 设置Gitea分支保护
- [ ] 实现结构化日志

### 低优先级（本月完成）
- [ ] 集成Grafana Dashboard
- [ ] 编写应急响应手册
- [ ] 定期安全审计自动化

## 审批
- 评估者：[你的名字]
- 日期：[2024-02-15]
- 审批状态：⚠️ 需改进后部署
```

> 🔧 **遇到问题？**
> 
> 不确定如何评估某个风险的严重性？把场景描述给AI：
> "我的Agent需要[描述操作]权限，可能的风险是什么？如何降低风险？"
> 
> AI会从多个角度分析风险，并给出防护建议。

---

## 🔑 7.5 实战：本地密码保险箱（macOS Keychain + TOTP）

前面讨论的n8n凭证隔离模式很优雅，但需要额外部署n8n服务。如果你只是个人用户，有没有更简单的方案？

答案是：**利用操作系统自带的安全基础设施**。macOS的Keychain（钥匙串）就是一个硬件级加密的密码管理器——它已经保管了你的WiFi密码、Safari密码，为什么不让Agent也用它？

### 7.5.1 方案设计：三层安全架构

```mermaid
graph TB
    Agent[🤖 OpenClaw Agent] --> OCS[openclaw-secure<br/>API密钥管理]
    Agent --> TOTP[totp CLI<br/>两步验证码]
    Agent --> APW[apw CLI<br/>iCloud密码访问]
    
    OCS --> KC[🔐 macOS Keychain<br/>硬件加密]
    TOTP --> KC
    APW --> KC
    
    KC --> SE[🔒 Secure Enclave<br/>T2/M系列芯片]
    
    style SE fill:#ff6b6b,stroke:#333,stroke-width:3px
    style KC fill:#ffd93d,stroke:#333,stroke-width:2px
```

**三个工具，三个用途**：

| 工具 | 用途 | 安装方式 |
|------|------|---------|
| `openclaw-secure` | 加密存储OpenClaw配置中的API密钥 | `npm install -g openclaw-secure` |
| `totp` | 生成TOTP两步验证码（替代Google Authenticator） | `brew install simnalamburt/x/totp` |
| `apw` | 读取Apple Passwords（iCloud钥匙串）中保存的密码 | `brew install bendews/homebrew-tap/apw` |

### 7.5.2 openclaw-secure：API密钥永不明文存储

OpenClaw的配置文件(`openclaw.json`)包含大量敏感信息：Telegram Bot Token、AI模型API Key、Webhook密钥等。明文存储这些凭证是一颗定时炸弹。

**加密流程**：

```bash
# 安装
npm install -g openclaw-secure

# 将配置中的所有敏感值存入Keychain
openclaw-secure stash
# → 提取11个API密钥 → 存入macOS Keychain
# → 配置文件中的值替换为 {SECURE:keyname} 占位符

# 恢复（例如修改配置后）
openclaw-secure restore
# → 从Keychain读取真实值 → 写回配置文件
```

**加密前**：
```json
{
  "channels": {
    "telegram": {
      "botToken": "1234567890:AAxxxxxxxxxxxxxxxxx"
    }
  },
  "providers": {
    "anthropic": {
      "apiKey": "sk-ant-xxxxxxxxxxxxxxxxx"
    }
  }
}
```

**加密后**：
```json
{
  "channels": {
    "telegram": {
      "botToken": "{SECURE:telegram-bot-token}"
    }
  },
  "providers": {
    "anthropic": {
      "apiKey": "{SECURE:anthropic-api-key}"
    }
  }
}
```

**安全性**：
- ✅ 配置文件可以安全地提交到Git（没有明文凭证）
- ✅ Keychain由macOS管理，T2/M系列芯片的Secure Enclave硬件加密
- ✅ 需要用户登录密码或Touch ID才能访问
- ✅ Agent运行时通过`openclaw-secure restore`临时恢复

### 7.5.3 TOTP：Agent自动生成两步验证码

许多服务（SSH、HPC系统、企业VPN）要求两步验证。有了`totp` CLI，Agent可以自动生成验证码，无需人工打开手机App。

```bash
# 添加TOTP密钥
totp add --secret JBSWY3DPEHPK3PXP --algorithm sha1 --digits 6 --period 30 my-service

# 生成当前验证码
totp my-service
# → 483927（30秒有效）
```

**与SSH结合的场景**：

```bash
# 某些HPC系统要求"密钥+TOTP"双因素认证
# Agent可以自动完成：

# 1. 获取TOTP验证码
CODE=$(totp miyabi-hpc)

# 2. 使用expect自动输入
expect -c "
  spawn ssh user@hpc.example.ac.jp
  expect \"Verification code:\"
  send \"$CODE\r\"
  interact
"
```

> ⚠️ **安全警告**
> TOTP密钥（secret）一旦添加到Keychain，Agent就拥有了两步验证能力。
> 只为Agent真正需要自动登录的服务添加TOTP，不要把所有服务的TOTP都给Agent。

### 7.5.4 apw：读取iCloud钥匙串中的密码

如果你用Safari/Apple Passwords保存了网站密码，`apw`可以让Agent直接读取——无需手动复制粘贴。

```bash
# 首次授权（需要在屏幕上确认）
apw auth

# 列出所有保存的密码
apw pw list

# 搜索特定服务的密码
apw pw get example.com
# → 返回用户名和密码
```

**与浏览器自动化结合**：

```
Agent工作流：
1. apw pw get au-login.kddi.com → 获取用户名/密码
2. 打开浏览器 → 导航到登录页
3. 自动填充凭证 → 登录
4. totp au-id → 获取验证码 → 完成双因素认证
5. 执行目标操作（如退订邮件）
```

### 7.5.5 安全原则

使用本地密码保险箱时，必须遵守以下原则：

1. **最小权限**：只给Agent它需要的密码，不是所有密码
2. **日志审计**：记录每次密码访问（谁、什么时候、为什么）
3. **不传输**：密码读取后直接使用，不存入文件、不发送到聊天
4. **定期清理**：不再需要的密钥及时删除
5. **人工确认**：高风险操作（银行、支付）必须人工确认后执行

```markdown
# vault skill 安全规则示例

## 🚫 绝对禁止
- 在聊天中显示明文密码
- 将密码写入任何文件
- 通过网络传输密码明文
- 未经用户确认访问金融类密码

## ✅ 允许
- 读取密码后直接在浏览器中填充
- 生成TOTP验证码用于自动登录
- 检查某个服务是否有保存的密码（不显示值）
```

### 7.5.6 方案对比：为什么选本地方案

| 维度 | 1Password CLI | 本地Keychain方案 |
|------|--------------|-----------------|
| 成本 | $36/年 | 免费 |
| 加密 | AES-256（云端） | Secure Enclave（硬件） |
| 数据位置 | 1Password服务器 | 本机芯片内 |
| 跨设备同步 | ✅ | ❌（iCloud除外） |
| 离线可用 | 部分 | ✅ 完全离线 |
| Agent集成 | 优秀（官方CLI） | 需要组合工具 |
| 适合场景 | 企业/团队 | 个人/单机Agent |

**选择建议**：
- 如果Agent只在一台机器上运行 → **本地Keychain方案**（零成本、最高安全）
- 如果需要跨设备、团队共享 → **1Password CLI**（便利性更好）

> 💡 **AI辅助提示**
> 想了解macOS Keychain的工作原理？问AI：
> "macOS Keychain和Secure Enclave是如何保护密码的？T2芯片在其中扮演什么角色？"

---

## 📌 7.6 本章小结

### 关键要点

1. **安全不是事后补救**  
   从设计第一天就考虑风险，而不是等出事后修补。

2. **凭证隔离是核心**  
   Agent不持有凭证（n8n Pattern）是最有效的防护手段。

3. **多层防护栏**  
   Pre-commit Hook + 分支保护 + 定期审计 = 纵深防御。

4. **最小权限原则**  
   Agent只应该有完成任务所需的最小权限，多一分都不给。

5. **可逆性优先**  
   能撤销的操作才能自动化；不可逆的必须人工审批。

6. **持续审计**  
   安全不是一次性任务，而是持续的监控和改进。

### 实践检查清单

在部署任何Agent之前，确认：

- [ ] **五问清单已完成**（7.4.1）
- [ ] **风险等级已评估**（低/中/高/极高）
- [ ] **自动化层次已选择**（L0-L5）
- [ ] **凭证已隔离**（使用n8n或类似方案）
- [ ] **权限已最小化**（sudo、API scope、文件权限）
- [ ] **Pre-commit Hook已设置**（TruffleHog扫描）
- [ ] **分支保护已启用**（禁止直接push到main）
- [ ] **日志和监控已配置**（结构化日志 + Dashboard）
- [ ] **应急响应流程已文档化**（停止Agent、轮换凭证、审计日志）
- [ ] **定期审计已安排**（每日自动 + 每周人工）

### 下一步

安全边界解决了"Agent不会造成灾难"的问题，但还有另一个关键问题：**Agent如何持续运行**？

第6章介绍了Cron和Heartbeat机制，第8章将深入探讨信息聚合与内容发现的实战场景。但在此之前，建议：

1. **审查现有Agent的安全性**：用本章的五问清单和决策矩阵重新评估
2. **实施至少一项防护栏**：优先选择Pre-commit Hook（最容易部署）
3. **记录你的决策**：为每个Agent写一份风险评估报告（见7.4.3）

> 📚 **延伸阅读**
> 
> 想深入了解安全架构和风险管理？问AI推荐资源：
> "推荐关于DevSecOps、零信任架构、威胁建模的书籍和课程。"
> 
> AI会根据你的背景推荐合适的学习资源（如OWASP Top 10、NIST框架、微软威胁建模工具等）。

---

**下一章预告**：

第8章《信息聚合与内容发现》将展示如何构建个性化的信息流Agent——从Reddit摘要到多源新闻聚合，从YouTube频道追踪到财报自动分析。你会学到：
- 如何设计过滤和排序策略（避免信息过载）
- 偏好学习机制（Agent如何理解你喜欢什么）
- 多源数据聚合的架构模式
- 质量评分算法的实现

我们会用**真实案例**（109+源的科技新闻聚合、AI公司财报追踪）展示如何让Agent成为你的个人情报分析师。

---

## 参考资料

本章引用的案例均来自 [awesome-openclaw-usecases](https://github.com/hesamsheikh/awesome-openclaw-usecases) 社区仓库：

- [n8n Workflow Orchestration](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/n8n-workflow-orchestration.md)
- [Self-Healing Home Server](https://github.com/hesamsheikh/awesome-openclaw-usecases/blob/main/usecases/self-healing-home-server.md)
